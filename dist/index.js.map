{"version":3,"file":"index.js","sources":["../src/bab/v3.ts","../src/mesh/updateArcRotateCameraPosition.ts","../src/camera/attachArcRotateCameraControls.ts","../src/bab/createCanvas.ts","../src/engine/createWebglEngine.ts","../src/vr/hellowVrWorld.ts","../src/bab/c3.ts","../src/bab/c4.ts","../src/model/pickMesh.ts","../src/model/walkMeshes.ts","../src/camera/attachUniversalCameraControls.ts","../src/camera/createTopDownCamera.ts","../src/camera/getCamera.ts","../src/camera/updateCamera.ts","../src/camera/getArcRotateCamera.ts","../src/camera/getUniversalCamera.ts","../src/camera/createDebugCamera.ts","../src/camera/Cameras.ts","../src/light/getLight.ts","../src/light/updateLight.ts","../src/light/getHemisphericLight.ts","../src/light/getPointLight.ts","../src/light/Lights.ts","../src/mesh/getMesh.ts","../src/material/updateStandardMaterial.ts","../src/material/updateMaterial.ts","../src/material/getMaterial.ts","../src/mesh/updateMesh.ts","../src/mesh/getBox.ts","../src/mesh/getBoxInstance.ts","../src/mesh/getSphere.ts","../src/mesh/pickMesh.ts","../src/mesh/calcTopOfMeshWorldPosition.ts","../src/mesh/walkMeshes.ts","../src/mesh/getPolyhedron.ts","../src/mesh/calcClientRectForMesh.ts","../src/mesh/destroyMesh.ts","../src/mesh/findClosestPick.ts","../src/mesh/getCylinder.ts","../src/mesh/getLine.ts","../src/mesh/getMeshAsync.ts","../src/mesh/getMeshInstance.ts","../src/mesh/getMeshInstanceAsync.ts","../src/mesh/getPlane.ts","../src/mesh/getTorusKnot.ts","../src/voxel/voxDataToCorrectedPoints.ts","../src/voxel/voxDataToSps.ts","../src/mesh/getVoxModel.ts","../src/mesh/isInstancedMesh.ts","../src/mesh/lookAt.ts","../src/mesh/mergeMeshes.ts","../src/mesh/pickMeshes.ts","../src/mesh/describeMesh.ts","../src/mesh/Meshes.ts","../src/bab/helloWorld.ts","../src/bab/Babs.ts","../src/engine/createWebGpuEngine.ts","../src/engine/isWebGpuCapable.ts","../src/engine/Engines.ts","../src/util/Timers.ts","../src/scene/renderOnce.ts","../src/model/fix/fixEyelashes.ts","../src/model/fix/fixEyes.ts","../src/model/fix/fixBumpMaps.ts","../src/model/fix/fixDazFigure.ts","../src/model/loadDazFigure.ts","../src/model/Models.ts","../src/texture/copyToCanvas.ts","../src/util/imageSrcToUrl.ts","../src/texture/imageToTexture.ts","../src/texture/layerToPlane.ts","../src/texture/imageLayersToScene.ts","../src/texture/builder.ts","../src/texture/drawOnTexture.ts","../src/texture/clearTexture.ts","../src/texture/debugImage.ts","../src/texture/destroyTexture.ts","../src/texture/drawBackgroundOnTexture.ts","../src/texture/drawTextOnTexture.ts","../src/texture/TEXTURE_SAMPLING_MODES.ts","../src/texture/getTexture.ts","../src/texture/updateTexture.ts","../src/texture/getDynamicTexture.ts","../src/texture/samplingModeNumber.ts","../src/texture/getHtmlElementTexture.ts","../src/texture/getPathTexture.ts","../src/texture/Textures.ts","../src/layer/getGlowLayer.ts","../src/layer/getHighlightLayer.ts","../src/layer/Layers.ts","../src/material/Materials.ts","../src/node/getTransformNode.ts","../src/node/Nodes.ts","../src/particle/getParticleSystem.ts","../src/particle/getSolidParticleSystem.ts","../src/particle/Sps.ts","../src/particle/Particles.ts","../src/ray/createRay.ts","../src/ray/pickWithRay.ts","../src/ray/Rays.ts","../src/scene/createScene.ts","../src/scene/toggleInspector.ts","../src/scene/Scenes.ts","../src/mesh/removeShadowFromMesh.ts","../src/shadow/addShadowToMesh.ts","../src/shadow/Shadows.ts","../src/special/Specials.ts","../src/sprite/createTextureAtlas.ts","../src/sprite/getSpriteManager.ts","../src/sprite/getSprite.ts","../src/sprite/Sprites.ts","../src/voxel/animateExplosion.ts","../node_modules/.pnpm/@babylonjs+core@8.6.1/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js","../node_modules/.pnpm/@babylonjs+core@8.6.1/node_modules/@babylonjs/core/Misc/tags.js","../src/voxel/voxDataToComplexModel.ts","../src/util/toOrderedString.ts","../src/voxel/groupMeshesByMaterial.ts","../src/voxel/voxDataToMergedModel.ts","../src/voxel/Voxels.ts","../src/debug/spsDebug.ts","../src/debug/spsDebug2.ts","../src/debug/Debugs.ts"],"sourcesContent":["import { Vector3 } from \"@babylonjs/core\";\nimport type { Point2, Point3 } from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\n\nexport function v3(\n  xOrPosition: number | Point3 | Point2 = 0,\n  y: number = 0,\n  z: number = 0\n) {\n  if (typeof xOrPosition === \"number\") {\n    return new Vector3(xOrPosition, y, z);\n  }\n\n  const [xx = 0, yy = 0, zz = 0] = toVec3(xOrPosition as Point3);\n  return new Vector3(xx, yy, zz);\n}\n","import type { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { v3 } from \"../bab/v3\";\n\nexport const updateArcRotateCameraPosition = (\n  camera: ArcRotateCamera,\n  position: Point3\n) => {\n  const currentAlpha = camera.alpha;\n  const currentBeta = camera.beta;\n  const currentRadius = camera.radius;\n  camera.target = camera.target.add(v3(position));\n  camera.radius = currentRadius;\n  camera.alpha = currentAlpha;\n  camera.beta = currentBeta;\n};\n","// import type { ArcRotateCamera } from \"babylonjs\";\n// import { Scene } from \"babylonjs\";\nimport type { AnimateState } from \"@mjt-engine/animate\";\nimport { Inputs } from \"@mjt-engine/input\";\nimport type { Point2 } from \"@mjt-engine/math\";\nimport { Maths, toVec2 } from \"@mjt-engine/math\";\nimport { updateArcRotateCameraPosition } from \"../mesh/updateArcRotateCameraPosition\";\nimport { v3 } from \"../bab/v3\";\nimport type { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\n\nexport const attachArcRotateCameraControls = (\n  camera: ArcRotateCamera,\n  options: Partial<{\n    keySensitivity: number;\n    mouseSensitivity: number;\n    parent: HTMLElement;\n    action: () => void;\n  }> = {}\n): AnimateState[] => {\n  const {\n    keySensitivity = 0.5,\n    mouseSensitivity = 0.05,\n    parent = document.body,\n    action = () => {},\n  } = options;\n\n  const defaultAlpha = camera.alpha;\n  const defaultBeta = camera.beta;\n  const defaultRadius = camera.radius;\n  const defaultTarget = v3(camera.target);\n  const update = (x = 0, y = 0, z = 0) => {\n    updateArcRotateCameraPosition(camera, [x, y, z]);\n    action();\n  };\n\n  const keyAnim = Inputs.listenToKey(\n    {\n      // Y up\n      w: () => {\n        update(-keySensitivity / 2, keySensitivity / 2, 0);\n      },\n      \"shift+w\": () => {\n        camera.radius -= keySensitivity;\n      },\n\n      // X left\n      a: () => {\n        update(-keySensitivity / 2, -keySensitivity / 2, 0);\n      },\n      \"shift+s\": () => {\n        camera.radius += keySensitivity;\n      },\n\n      // Y down\n      s: () => {\n        update(keySensitivity / 2, -keySensitivity / 2, 0);\n      },\n\n      // X right\n      d: () => {\n        update(keySensitivity / 2, keySensitivity / 2, 0);\n      },\n      v: () => {\n        camera.beta = camera.beta + keySensitivity / 8;\n        action();\n      },\n      z: () => {\n        camera.beta = camera.beta - keySensitivity / 8;\n        action();\n      },\n      c: () => {\n        camera.alpha = defaultAlpha;\n        camera.beta = defaultBeta;\n        camera.radius = defaultRadius;\n        action();\n        // camera.target = defaultTarget;\n      },\n      \"shift+d\": () => {\n        camera.alpha = camera.alpha + keySensitivity / 8;\n\n        action();\n      },\n      \"shift+a\": () => {\n        camera.alpha = camera.alpha - keySensitivity / 8;\n\n        action();\n      },\n    },\n    {\n      autoUp: false,\n      parent,\n    }\n  );\n  const MOUSE_STATE = {\n    lastPosition: undefined as Point2 | undefined,\n  };\n  parent.addEventListener(\"pointerdown\", (event) => {\n    if (event.buttons === 4) {\n      MOUSE_STATE.lastPosition = event;\n    }\n  });\n  parent.addEventListener(\"pointermove\", (event) => {\n    if (event.buttons !== 4) {\n      return;\n    }\n    const { lastPosition: auxDownLast = event } = MOUSE_STATE;\n    MOUSE_STATE.lastPosition = event;\n    const diff = Maths.subtract2(auxDownLast, event);\n    const [x, y] = toVec2(diff);\n\n    if (event.buttons === 4 && event.shiftKey) {\n      camera.beta = camera.beta + y * mouseSensitivity;\n      return;\n    }\n\n    if (event.buttons === 4) {\n      update(y * mouseSensitivity, -y * mouseSensitivity, 0);\n      update(x * mouseSensitivity, x * mouseSensitivity, 0);\n    }\n  });\n\n  // zoom\n  const mouseAnim = Inputs.listenToMouse(\n    {\n      wheel: (event) => {\n        if (event instanceof WheelEvent) {\n          const delta = event.deltaY * mouseSensitivity;\n          camera.radius += delta;\n          action();\n        }\n      },\n    },\n    {\n      parent,\n    }\n  );\n  return [keyAnim, mouseAnim];\n};\n","\nexport const createCanvas = ({\n  width = 320, height = 320,\n}: {\n  width: number;\n  height: number;\n}) => {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n};\n","import { Engine } from \"@babylonjs/core\";\nimport type { EngineOptions } from \"@babylonjs/core/Engines/thinEngine\";\nimport { createCanvas } from \"../bab/createCanvas\";\n\nexport type CreateEngineOptions = EngineOptions & {\n  antialias?: boolean;\n  width?: number;\n  height?: number;\n  canvas?: HTMLCanvasElement | OffscreenCanvas;\n};\nexport const createWebGlEngine = (\n  optionsOrCanvas?: CreateEngineOptions | HTMLCanvasElement | OffscreenCanvas\n) => {\n  const options: CreateEngineOptions = !(\n    optionsOrCanvas instanceof HTMLCanvasElement ||\n    optionsOrCanvas instanceof OffscreenCanvas\n  )\n    ? optionsOrCanvas ?? {}\n    : {};\n  const canvas =\n    optionsOrCanvas instanceof HTMLCanvasElement ||\n    optionsOrCanvas instanceof OffscreenCanvas\n      ? optionsOrCanvas\n      : createCanvas({\n          width: optionsOrCanvas?.width ?? 320,\n          height: optionsOrCanvas?.height ?? 320,\n        });\n  const { antialias } = options;\n\n  // const prop\n  const engine = new Engine(canvas, antialias, {\n    powerPreference: \"high-performance\",\n    ...options,\n  });\n  // engine.loadingScreen = undefined!;\n  engine.hideLoadingUI();\n  return engine;\n};\n","import * as BABYLON from \"@babylonjs/core\";\nimport * as GUI from \"@babylonjs/gui\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const helloVrWorld = (engine: BabEngine = createWebGlEngine()) => {\n  // Create scene\n  var scene = new BABYLON.Scene(engine);\n\n  // Create simple sphere\n  var sphere = BABYLON.Mesh.CreateIcoSphere(\n    \"sphere\",\n    { radius: 0.2, flat: true, subdivisions: 1 },\n    scene\n  );\n  sphere.position.y = 3;\n  const material = new BABYLON.StandardMaterial(\"sphere material\", scene);\n  sphere.material = material;\n\n  // Lights and camera\n  var light = new BABYLON.DirectionalLight(\n    \"light\",\n    new BABYLON.Vector3(0, -0.5, 1.0),\n    scene\n  );\n  light.position = new BABYLON.Vector3(0, 5, -2);\n  var camera = new BABYLON.ArcRotateCamera(\n    \"camera\",\n    -Math.PI / 2,\n    Math.PI / 4,\n    3,\n    new BABYLON.Vector3(0, 3, 0),\n    scene\n  );\n  const canvas = engine.getRenderingCanvas();\n  camera.attachControl(canvas, true);\n  if (!camera) {\n    throw new Error(\"Failed to create ArcRotateCamera\");\n  }\n  camera.beta += 0.8;\n\n  // Default Environment\n  var environment = scene.createDefaultEnvironment({\n    enableGroundShadow: true,\n    groundYBias: 2.8,\n  });\n  if (!environment) {\n    throw new Error(\"Failed to create default environment\");\n  }\n  environment.setMainColor(BABYLON.Color3.FromHexString(\"#74b9ff\"));\n\n  // Shadows\n  var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);\n  shadowGenerator.useBlurExponentialShadowMap = true;\n  shadowGenerator.blurKernel = 32;\n  shadowGenerator.addShadowCaster(sphere, true);\n\n  // Enable VR\n  var vrHelper = scene.createDefaultVRExperience({\n    createDeviceOrientationCamera: false,\n    useXR: true,\n  });\n  if (!vrHelper) {\n    throw new Error(\"Failed to create VR experience\");\n  }\n  if (!environment.ground) {\n    throw new Error(\"Default environment does not have a ground mesh\");\n  }\n  vrHelper.enableTeleportation({ floorMeshes: [environment.ground] });\n\n  // Runs every frame to rotate the sphere\n  scene.onBeforeRenderObservable.add(() => {\n    sphere.rotation.y += 0.0001 * scene.getEngine().getDeltaTime();\n    sphere.rotation.x += 0.0001 * scene.getEngine().getDeltaTime();\n  });\n\n  // GUI\n  var plane = BABYLON.Mesh.CreatePlane(\"plane\", 1, scene);\n  plane.position = new BABYLON.Vector3(0.4, 4, 0.4);\n  var advancedTexture = GUI.AdvancedDynamicTexture.CreateForMesh(plane);\n  var panel = new GUI.StackPanel();\n  advancedTexture.addControl(panel);\n  var header = new GUI.TextBlock();\n  header.text = \"Color GUI\";\n  header.height = \"100px\";\n  header.color = \"white\";\n  header.textHorizontalAlignment = GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n  header.fontSize = \"120\";\n  panel.addControl(header);\n  var picker = new GUI.ColorPicker();\n  picker.value = material.diffuseColor;\n  picker.horizontalAlignment = GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n  picker.height = \"350px\";\n  picker.width = \"350px\";\n  picker.onValueChangedObservable.add(function (value) {\n    material.diffuseColor.copyFrom(value);\n  });\n  panel.addControl(picker);\n\n  vrHelper.onAfterEnteringVRObservable.add(() => {\n    if (scene.activeCamera === vrHelper.vrDeviceOrientationCamera) {\n      BABYLON.FreeCameraDeviceOrientationInput.WaitForOrientationChangeAsync(\n        1000\n      )\n        .then(() => {\n          // Successfully received sensor input\n        })\n        .catch(() => {\n          alert(\n            \"Device orientation camera is being used but no sensor is found, prompt user to enable in safari settings\"\n          );\n        });\n    }\n  });\n\n  return scene;\n};\n","import { Color3 } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\n\nexport const c3 = (color: string) => {\n  const hex = Colors.builder({ color }).hex();\n  return Color3.FromHexString(hex);\n};\n","import { Color4 } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\n\n\nexport const c4 = (color: string) => {\n  const c = Colors.builder({ color });\n  const result = Color4.FromHexString(c.hex());\n  result.a = c.alpha();\n  return result;\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport { Matrix } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { ModelMesh } from \"./ModelBuilder\";\n\nexport const pickMesh = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: ModelMesh) => boolean;\n  }> = {}\n) => {\n  const { camera = scene.activeCamera, predicate = () => true } = options;\n  const ray = scene.createPickingRay(x, y, Matrix.Identity(), camera);\n  const hit = scene.pickWithRay(ray, predicate);\n  return hit?.pickedMesh;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\n\nexport const walkMeshes = (\n  mesh: AbstractMesh | Scene,\n  walker: (mesh: AbstractMesh) => void\n): void => {\n  if (mesh instanceof Scene) {\n    return mesh.meshes.forEach((m) => walkMeshes(m, walker));\n  }\n  walker(mesh);\n  mesh.getChildMeshes().forEach((m) => walkMeshes(m, walker));\n};\n","import { Inputs } from \"@mjt-engine/input\";\nimport { isDefined, isUndefined } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport { pickMesh } from \"../model/pickMesh\";\nimport { walkMeshes } from \"../model/walkMeshes\";\nimport type { UniversalCamera } from \"@babylonjs/core\";\n\nexport const attachUniversalCameraControls = (\n  camera: UniversalCamera,\n  options: Partial<{\n    keySensitivity: number;\n    mouseSensitivity: number;\n    parent: HTMLElement;\n  }> = {}\n) => {\n  const {\n    keySensitivity = 0.05,\n    mouseSensitivity = 0.05,\n    parent = document.body,\n  } = options;\n\n  Inputs.listenToKey(\n    {\n      w: () => {\n        camera.position.addInPlace(v3(0, 0, -keySensitivity));\n      },\n      a: () => {\n        camera.rotation.y -= keySensitivity / 2;\n      },\n      s: () => {\n        camera.position.addInPlace(v3(0, 0, keySensitivity));\n      },\n      d: () => {\n        camera.rotation.y += keySensitivity / 2;\n      },\n      i: () => {\n        camera.position.addInPlace(v3(0, keySensitivity, 0));\n      },\n      j: () => {\n        camera.position.addInPlace(v3(keySensitivity, 0, 0));\n      },\n      k: () => {\n        camera.position.addInPlace(v3(0, -keySensitivity, 0));\n      },\n      l: () => {\n        camera.position.addInPlace(v3(-keySensitivity, 0, 0));\n      },\n    },\n    {\n      propagate: false,\n      parent,\n    }\n  );\n\n  Inputs.listenToMouse(\n    {\n      wheel: (event) => {\n        if (event instanceof WheelEvent) {\n          if (event.shiftKey) {\n            const delta = event.deltaX * mouseSensitivity;\n            camera.position.addInPlace(v3(0, -delta, 0));\n            return;\n          }\n\n          const delta = event.deltaY * mouseSensitivity;\n          camera.position.addInPlace(v3(0, 0, delta));\n        }\n      },\n      click: (e) => {\n        if (e.buttons === 0) {\n          const position = e as unknown as HasLayerPosition;\n          const scene = camera.getScene();\n          const mesh = pickMesh(scene, position.layerX, position.layerY);\n          if (isDefined(mesh)) {\n            console.log({ mesh });\n            walkMeshes(scene, (m) => {\n              if (isUndefined(m.material)) {\n                return;\n              }\n              if (m.material) {\n                m.material.wireframe = false;\n              }\n            });\n            if (mesh.material) {\n              mesh.material.wireframe = true;\n            }\n          }\n        }\n      },\n      auxclick: (e) => {\n        if (e.button !== 1) {\n          return;\n        }\n        const scene = camera.getScene();\n        const mesh = pickMesh(scene, e.clientX, e.clientY);\n        if (isUndefined(mesh)) {\n          return;\n        }\n      },\n      contextmenu: (e) => {\n        console.log(\"should context\");\n      },\n    },\n    {\n      propagate: false,\n      parent,\n    }\n  );\n};\n\nexport type HasLayerPosition = { layerX: number; layerY: number };\n","import type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport { UniversalCamera } from \"@babylonjs/core\";\nimport { Camera } from \"@babylonjs/core\";\nimport { BabUniversalCamera } from \"../type/BabCamera\";\n\nexport const createTopDownCamera = (\n  scene: Scene,\n  name: string,\n  {\n    unitsTall = 1,\n    unitsWide = 1,\n    cameraLevel = -100,\n\n    disposeActive = false,\n  }: Partial<{\n    cameraLevel: number;\n    disposeActive: boolean;\n    unitsTall: number;\n    unitsWide: number;\n  }> = {}\n): BabUniversalCamera => {\n  if (disposeActive) {\n    scene?.activeCamera?.dispose();\n  }\n  const camera = new UniversalCamera(name, v3(0, 0, cameraLevel), scene);\n  camera.target = v3(0, 0, 0);\n  camera.rotation = v3(0, 0, Math.PI); // Y up\n  camera.orthoTop = -unitsTall / 2;\n  camera.orthoBottom = unitsTall / 2;\n  camera.orthoLeft = unitsWide / 2;\n  camera.orthoRight = -unitsWide / 2;\n  camera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n  return camera;\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getCamera = <T extends Camera>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const camera = scene.getCameraByName(name);\n  if (isDefined(camera)) {\n    return camera as T;\n  }\n  return producer();\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport type { Camera } from \"@babylonjs/core\";\nimport { TargetCamera } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport type { AllCameraOptions } from \"./Cameras\";\nimport { CAMERA_MODES } from \"./Cameras\";\n\nexport const updateCamera = (camera: Camera, options: AllCameraOptions) => {\n  const {\n    alpha,\n    beta,\n    radius,\n    target,\n    position,\n    rotation,\n    minZ,\n    maxZ,\n    mode,\n    orthoTop,\n    orthoBottom,\n    orthoLeft,\n    orthoRight,\n  } = options;\n  iff(position, (value) => {\n    camera.position = v3(value);\n  });\n  iff(minZ, (value) => {\n    camera.minZ = value;\n  });\n  iff(maxZ, (value) => {\n    camera.maxZ = value;\n  });\n\n  iff(mode, (value) => {\n    camera.mode = CAMERA_MODES[value];\n  });\n\n  iff(mode, (value) => {\n    camera.mode = CAMERA_MODES[value];\n  });\n\n  iff(orthoTop, (value) => {\n    camera.orthoTop = value;\n  });\n\n  iff(orthoBottom, (value) => {\n    camera.orthoBottom = value;\n  });\n\n  iff(orthoLeft, (value) => {\n    camera.orthoLeft = value;\n  });\n\n  iff(orthoRight, (value) => {\n    camera.orthoRight = value;\n  });\n\n  if (camera instanceof TargetCamera) {\n    iff(rotation, (value) => {\n      camera.rotation = v3(value);\n    });\n    iff(target, (value) => {\n      camera.target = v3(value);\n    });\n  }\n\n  if (camera instanceof ArcRotateCamera) {\n    iff(alpha, (value) => {\n      camera.alpha = value;\n    });\n    iff(beta, (value) => {\n      camera.beta = value;\n    });\n    iff(radius, (value) => {\n      camera.radius = value;\n    });\n  }\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { ArcRotateCameraOptions } from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nexport const getArcRotateCamera = (\n  scene: Scene,\n  name: string,\n  options: ArcRotateCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    const { alpha = 0, beta = 0, radius = 2, target } = options;\n    return new ArcRotateCamera(name, alpha, beta, radius, v3(target), scene);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n","import { UniversalCamera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { UniversalCameraOptions } from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nexport const getUniversalCamera = (\n  scene: Scene,\n  name: string,\n  options: UniversalCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    const { position } = options;\n    return new UniversalCamera(name, v3(position), scene);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport { Camera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\n\nexport const createDebugCamera = (scene: Scene, name: string) => {\n  scene?.activeCamera?.dispose();\n  const canvas = scene.getEngine().getRenderingCanvas();\n  const alpha = -Math.PI / 2;\n  const beta = Math.PI / 2.5;\n  const camera = new ArcRotateCamera(name, alpha, beta, 15, v3(0, 0, 0), scene);\n  camera.attachControl(canvas, true);\n  camera.mode = Camera.PERSPECTIVE_CAMERA;\n};\n","import type { Vec3 } from \"@mjt-engine/math\";\nimport { attachArcRotateCameraControls } from \"./attachArcRotateCameraControls\";\nimport { attachUniversalCameraControls } from \"./attachUniversalCameraControls\";\nimport { createTopDownCamera } from \"./createTopDownCamera\";\nimport { getArcRotateCamera } from \"./getArcRotateCamera\";\nimport { getCamera } from \"./getCamera\";\nimport { getUniversalCamera } from \"./getUniversalCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nimport { Camera } from \"@babylonjs/core\";\nimport { createDebugCamera } from \"./createDebugCamera\";\n\nexport const CAMERA_MODES = {\n  orthographic: Camera.ORTHOGRAPHIC_CAMERA,\n  perspective: Camera.PERSPECTIVE_CAMERA,\n};\nexport type CameraModeMap = typeof CAMERA_MODES;\nexport type CameraOptions = Partial<{\n  mode: keyof CameraModeMap;\n  position: Vec3;\n  minZ: number;\n  maxZ: number;\n  target: Vec3;\n\n  orthoTop: number;\n  orthoBottom: number;\n  orthoLeft: number;\n  orthoRight: number;\n}>;\nexport type ArcRotateCameraOptions = Partial<\n  CameraOptions & {\n    alpha: number;\n    beta: number;\n    radius: number;\n  }\n>;\n\nexport type UniversalCameraOptions = Partial<\n  CameraOptions & {\n    rotation: Vec3;\n  }\n>;\nexport type AllCameraOptions = ArcRotateCameraOptions & UniversalCameraOptions;\n\nexport const Cameras = {\n  getArcRotateCamera,\n  getCamera,\n  updateCamera,\n  getUniversalCamera,\n  attachArcRotateCameraControls,\n  attachUniversalCameraControls,\n  createTopDownCamera,\n  createDebugCamera,\n};\n","import type { Light } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getLight = <T extends Light>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const light = scene.getLightByName(name);\n  if (isDefined(light)) {\n    return light as T;\n  }\n  return producer();\n};\n","import { HemisphericLight } from \"@babylonjs/core\";\nimport type { Light } from \"@babylonjs/core\";\nimport { PointLight } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport type { AllLightOptions } from \"./Lights\";\n\nexport const updateLight = (light: Light, options: AllLightOptions) => {\n  const { intensity, direction, position } = options;\n  iff(intensity, (value) => {\n    light.intensity = value;\n  });\n\n  if (light instanceof HemisphericLight) {\n    iff(direction, (value) => {\n      light.direction = v3(value);\n    });\n  }\n\n  if (light instanceof PointLight) {\n    iff(position, (value) => {\n      light.position = v3(value);\n    });\n  }\n};\n","import { HemisphericLight } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { HemisphericLightOptions } from \"./Lights\";\nimport { getLight } from \"./getLight\";\nimport { updateLight } from \"./updateLight\";\n\nexport const getHemisphericLight = (\n  scene: Scene,\n  name: string,\n  options: HemisphericLightOptions = {}\n) => {\n  const light = getLight(scene, name, () => {\n    const { direction } = options;\n    return new HemisphericLight(name, v3(direction), scene);\n  });\n  updateLight(light, options);\n  return light;\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { PointLightOptions } from \"./Lights\";\nimport { getLight } from \"./getLight\";\nimport { updateLight } from \"./updateLight\";\nimport { PointLight } from \"@babylonjs/core\";\n\nexport const getPointLight = (\n  scene: Scene,\n  name: string,\n  options: PointLightOptions = {}\n) => {\n  const light = getLight(scene, name, () => {\n    const { position } = options;\n    return new PointLight(name, v3(position), scene);\n  });\n  updateLight(light, options);\n  return light;\n};\n","import type { Vec3 } from \"@mjt-engine/math\";\nimport { getHemisphericLight } from \"./getHemisphericLight\";\nimport { getLight } from \"./getLight\";\nimport { getPointLight } from \"./getPointLight\";\nimport { updateLight } from \"./updateLight\";\n\nexport type LightOptions = Partial<{ intensity: number }>;\nexport type HemisphericLightOptions = Partial<\n  LightOptions & { direction: Vec3 }\n>;\nexport type PointLightOptions = Partial<LightOptions & { position: Vec3 }>;\n\nexport type AllLightOptions = LightOptions &\n  HemisphericLightOptions &\n  PointLightOptions;\n\nexport const Lights = {\n  getLight,\n  getHemisphericLight,\n  getPointLight,\n  updateLight,\n};\n","import type { InstancedMesh } from \"@babylonjs/core\";\nimport type { Mesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getMesh = <T extends Mesh | InstancedMesh>(\n  scene: Scene,\n  name: string,\n  producer: (instance?: T) => T,\n  updatable: boolean = false\n): T => {\n  const meshMaybe = scene.getMeshByName(name);\n  if (isDefined(meshMaybe) && !updatable) {\n    return meshMaybe as T;\n  }\n  if (isDefined(meshMaybe) && updatable) {\n    return producer(meshMaybe as T) as T;\n  }\n  return producer();\n};\n","import type { StandardMaterial } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport { iff } from \"@mjt-engine/object\";\nimport { c3 } from \"../bab/c3\";\nimport type { AllMaterialOptions } from \"./Materials\";\n\nexport const updateStandardMaterial = (\n  scene: Scene,\n  material: StandardMaterial,\n  options: AllMaterialOptions\n) => {\n  const {\n    alpha,\n    diffuseTexture,\n    emissiveTexture,\n    ambientTexture,\n    opacityTexture,\n    diffuseColor,\n    specularColor,\n    ambientColor,\n    emissiveColor,\n  } = options;\n\n  iff(diffuseTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.diffuseTexture = texture;\n  });\n  iff(emissiveTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.emissiveTexture = texture;\n  });\n  iff(ambientTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.ambientTexture = texture;\n  });\n  iff(opacityTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.opacityTexture = texture;\n  });\n  iff(diffuseColor, (value) => {\n    material.diffuseColor = c3(value);\n    const colorAlpha = Colors.from(value).alpha();\n    if (colorAlpha < 1) {\n      material.alpha = colorAlpha;\n    }\n  });\n  iff(specularColor, (value) => {\n    material.specularColor = c3(value);\n  });\n  iff(ambientColor, (value) => {\n    material.ambientColor = c3(value);\n  });\n  iff(emissiveColor, (value) => {\n    material.emissiveColor = c3(value);\n  });\n\n  iff(alpha, (value) => {\n    material.alpha = value;\n  });\n};\n","import type { Material } from \"@babylonjs/core\";\nimport { StandardMaterial } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { AllMaterialOptions } from \"./Materials\";\nimport { updateStandardMaterial } from \"./updateStandardMaterial\";\n\nexport const updateMaterial = (\n  scene: Scene,\n  material: Material,\n  options: AllMaterialOptions\n) => {\n  if (material instanceof StandardMaterial) {\n    updateStandardMaterial(scene, material, options);\n  }\n};\n","import { isDefined } from \"@mjt-engine/object\";\nimport type { MaterialTypeMap } from \"./MaterialTypeMap\";\nimport { updateMaterial } from \"./updateMaterial\";\nimport type { AllMaterialOptions } from \"./Materials\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { StandardMaterial } from \"@babylonjs/core\";\nimport { PBRMaterial } from \"@babylonjs/core\";\n\ntype VisualMaterialType = keyof MaterialTypeMap;\n\nexport const getMaterial = <T extends VisualMaterialType = VisualMaterialType>(\n  scene: Scene,\n  name: string,\n  options: T | AllMaterialOptions = \"standard\"\n): MaterialTypeMap[T] => {\n  const material = scene.getMaterialByName(name);\n  if (isDefined(material)) {\n    // updateMaterial(scene, material, options);\n    return material as MaterialTypeMap[T];\n  }\n\n  const type =\n    typeof options === \"string\" ? options : options?.type ?? \"standard\";\n\n  switch (type) {\n    case \"standard\": {\n      const material = new StandardMaterial(name, scene) as MaterialTypeMap[T];\n      updateMaterial(scene, material, options);\n      return material;\n    }\n    case \"pbr\": {\n      const material = new PBRMaterial(name, scene) as MaterialTypeMap[T];\n      updateMaterial(scene, material, options);\n      return material;\n    }\n    default: {\n      throw new Error(`Unknown material type: '${type}'`);\n    }\n  }\n};\n","import { StandardMaterial } from \"@babylonjs/core\";\nimport type { InstancedMesh } from \"@babylonjs/core\";\nimport { Mesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { Point2, Point3 } from \"@mjt-engine/math\";\nimport { iff, isDefined } from \"@mjt-engine/object\";\nimport { c3 } from \"../bab/c3\";\nimport { v3 } from \"../bab/v3\";\nimport { getMaterial } from \"../material/getMaterial\";\n\nexport type MeshOptions = Partial<{\n  position: Point3 | Point2;\n  // texture: string;\n  color: string;\n  material: string;\n  receiveShadows: boolean;\n}>;\n\nexport const updateMesh = (\n  scene: Scene,\n  mesh: Mesh | InstancedMesh,\n  options: MeshOptions\n) => {\n  const { position, color, material, receiveShadows } = options;\n\n  if (mesh instanceof Mesh && isDefined(material)) {\n    mesh.material = getMaterial(scene, material, \"standard\");\n  }\n\n  if (mesh instanceof Mesh && isDefined(receiveShadows)) {\n    mesh.receiveShadows = receiveShadows;\n  }\n\n  iff(position, (p) => {\n    mesh.position = v3(p);\n  });\n\n  iff(color, (c) => {\n    const material = mesh.material;\n    if (material instanceof StandardMaterial) {\n      material.diffuseColor = c3(c);\n      const alpha = Colors.from(c).alpha();\n      if (alpha < 1) {\n        material.alpha = alpha;\n      }\n      material.specularColor = c3(\"black\");\n      material.ambientColor = c3(c);\n      material.emissiveColor = c3(c);\n    }\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { c4 } from \"../bab/c4\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport type BoxOptions = Partial<{\n  width: number;\n  height: number;\n  depth: number;\n  colors: string[];\n}>;\n\nexport const getBox = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions & BoxOptions = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { width = 1, height = 1, depth = 1, colors } = options;\n    const mesh = MeshBuilder.CreateBox(\n      name,\n      {\n        width,\n        height,\n        depth,\n        faceColors: isDefined(colors) ? colors.map(c4) : undefined,\n      },\n      scene\n    );\n\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { Mesh } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isUndefined } from \"@mjt-engine/object\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getBoxInstance = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      width: number;\n      height: number;\n      depth: number;\n      receiveShadows: boolean;\n    }>\n) => {\n  const {\n    width = 1,\n    height = 1,\n    depth = 1,\n    material,\n    receiveShadows = false,\n  } = options;\n  // return getMesh(scene, name, () => {\n  const rootName = `box-instance-root-${JSON.stringify([\n    width,\n    height,\n    depth,\n    material,\n    receiveShadows,\n  ])}`;\n  let rootMesh = scene.getMeshByName(rootName) as Mesh;\n  if (isUndefined(rootMesh)) {\n    rootMesh = MeshBuilder.CreateBox(rootName, { width, height, depth }, scene);\n    rootMesh.receiveShadows = receiveShadows;\n    rootMesh.isVisible = false;\n    if (!material) {\n      throw new Error(\"No material\", { cause: options });\n    }\n    rootMesh.material = getMaterial(scene, material, \"standard\");\n  }\n  const mesh = rootMesh.createInstance(name);\n  updateMesh(scene, mesh, options);\n  return mesh;\n  // });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getSphere = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      radius: number;\n    }>\n) => {\n  const { radius = 0.5 } = options;\n\n  return getMesh(scene, name, () => {\n    const mesh = MeshBuilder.CreateSphere(\n      name,\n      { diameter: radius * 2 },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport { Matrix } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickMesh = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: AbstractMesh) => boolean;\n  }> = {}\n) => {\n  const {\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n    camera = scene.activeCamera,\n  } = options;\n  const ray = scene.createPickingRay(x, y, Matrix.Identity(), camera);\n  const hit = scene.pickWithRay(ray, predicate);\n  return hit?.pickedMesh;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\n\nexport const calcTopOfMeshWorldPosition = (mesh: AbstractMesh) => {\n  mesh.computeWorldMatrix(true);\n  mesh.refreshBoundingInfo({});\n  const [x, y, z] = toVec3(mesh.getAbsolutePosition());\n\n  // const radius = mesh.getBoundingInfo().boundingSphere.radius;\n  const radius = mesh.getBoundingInfo().boundingSphere.radius;\n  // const top = mesh.getBoundingInfo().boundingBox.\n  return [x, y, z - radius] as Point3;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\n\nexport const walkMeshes = (\n  mesh: AbstractMesh | Scene,\n  walker: (mesh: AbstractMesh) => void\n): void => {\n  if (mesh instanceof Scene) {\n    return mesh.meshes.forEach((m) => walkMeshes(m, walker));\n  }\n  walker(mesh);\n  mesh.getChildMeshes().forEach((m) => walkMeshes(m, walker));\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const BabPolyMap = {\n  tetrahedron: 0,\n  octahedron: 1,\n  dodecahedron: 2,\n  icosahedron: 3,\n  rhombicuboctahadron: 4,\n  triangularPrism: 5,\n  pentagonalPrism: 6,\n  hexagonalPrism: 7,\n  squarePyramid: 8,\n  pentagonalPyramid: 9,\n  triangularDipyramid: 10,\n  pentagonalDipryramid: 11,\n  elongatedSquareDipyramid: 12,\n  elongatedPentagonalDipyramid: 13,\n  elongatedPentagonalCupola: 14,\n};\n\nexport const getPolyhedron = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      size: number;\n      type: keyof typeof BabPolyMap;\n      material: string;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { size = 1, type = \"tetrahedron\" } = options;\n    const mesh = MeshBuilder.CreatePolyhedron(\n      name,\n      { type: BabPolyMap[type], size },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import { Vector3 } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { extent } from \"d3-array\";\n\n/** @see https://forum.babylonjs.com/t/get-mesh-bounding-box-position-and-size-in-2d-screen-coordinates/1058  */\nexport const calcClientRectForMesh = (mesh: AbstractMesh) => {\n  // get bounding box of the mesh\n  const meshVectors = mesh.getBoundingInfo().boundingBox.vectors;\n  const scene = mesh.getScene();\n  const canvas = scene.getEngine().getRenderingCanvas();\n  if (!canvas) {\n    throw new Error(\"No canvas for scene\", { cause: scene });\n  }\n\n  // get the matrix and viewport needed to project the vectors onto the screen\n  const worldMatrix = mesh.getWorldMatrix();\n  const transformMatrix = scene.getTransformMatrix();\n  const viewport = scene.activeCamera!.viewport;\n\n  // loop though all the vectors and project them against the current camera viewport to get a set of coordinates\n  const coordinates = meshVectors.map((v) => {\n    const proj = Vector3.Project(v, worldMatrix, transformMatrix, viewport);\n    proj.x = proj.x * canvas.clientWidth;\n    proj.y = proj.y * canvas.clientHeight;\n    return proj;\n  });\n\n  // get the min and max for all the coordinates so we can calculate the largest possible screen size\n  // using d3.extent\n  const [minX, maxX] = extent(coordinates, (c) => c.x) as number[];\n  const [minY, maxY] = extent(coordinates, (c) => c.y) as number[];\n\n  // return a ClientRect from this\n  const rect = {\n    width: maxX - minX,\n    height: maxY - minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n  };\n\n  return rect;\n};\n","import type { Scene } from \"@babylonjs/core\";\n\nexport const destroyMesh = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    recurse: boolean;\n    disposeMaterials: boolean;\n    disposeTextures: boolean;\n  }> = {}\n) => {\n  const {\n    recurse = true,\n    disposeMaterials = false,\n    disposeTextures = false,\n  } = options;\n  const mesh = scene.getMeshByName(name);\n  if (!mesh) {\n    return;\n  }\n  mesh.dispose(!recurse, false);\n  if (disposeMaterials) {\n    const material = mesh.material;\n    if (!material) {\n      return;\n    }\n    material.name = `DISPOSED-${material.name}`;\n    material?.dispose(true, disposeTextures);\n    scene.removeMaterial(material);\n  }\n  scene.removeMesh(mesh);\n};\n","import type { PickingInfo } from \"@babylonjs/core/Collisions/pickingInfo\";\nimport { isUndefined } from \"@mjt-engine/object\";\n\nexport const findClosestPick = (picks: PickingInfo[]) => {\n  if (isUndefined(picks)) {\n    return undefined;\n  }\n  picks.sort((a, b) => {\n    return a.distance - b.distance;\n  });\n  return picks[0];\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getCylinder = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      height: number;\n      arc: number;\n      radius: number;\n      tag: string | string[];\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { arc = 1, height = 1, radius = 0.5, tag } = options;\n    const mesh = MeshBuilder.CreateCylinder(\n      name,\n      {\n        height,\n        arc,\n        diameter: radius * 2,\n      },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { LinesMesh } from \"@babylonjs/core/Meshes/linesMesh\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { c4 } from \"../bab/c4\";\nimport { v3 } from \"../bab/v3\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getLine = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      points: Point3[];\n      colors: string[];\n      updatable: boolean;\n      useVertexAlpha: boolean;\n    }>\n) => {\n  const { updatable = false } = options;\n\n  return getMesh(\n    scene,\n    name,\n    (instance: LinesMesh | undefined) => {\n      return buildLineMesh(scene, name, {\n        ...options,\n        instance,\n        // updatable: undefined,\n      });\n    },\n    updatable\n  );\n};\n\nconst buildLineMesh = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      points: Point3[];\n      colors: string[];\n      updatable: boolean;\n      useVertexAlpha: boolean;\n      instance: LinesMesh;\n    }>\n) => {\n  const {\n    colors = [],\n    points = [],\n    color = \"white\",\n    updatable = false,\n    useVertexAlpha,\n    instance,\n  } = options;\n  const pointColors = points\n    .map((_, index) => colors[index] ?? color)\n    .map((c) => c4(c));\n  const fleshedPoints = points.map((p) => v3(p));\n  const mesh = MeshBuilder.CreateLines(name, {\n    points: fleshedPoints,\n    colors: pointColors,\n    updatable,\n    useVertexAlpha,\n    instance,\n  });\n  updateMesh(scene, mesh, options);\n  return mesh;\n};\n","import type { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getMeshAsync = <T extends Mesh | InstancedMesh>(\n  scene: Scene,\n  name: string,\n  producer: () => Promise<T>\n): Promise<T> => {\n  const meshMaybe = scene.getMeshByName(name);\n  if (isDefined(meshMaybe)) {\n    return Promise.resolve(meshMaybe) as Promise<T>;\n  }\n  return producer();\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { getMesh } from \"./getMesh\";\n\nexport const getMeshInstance = <T extends Mesh>(\n  scene: Scene,\n  name: string,\n  rootName: string,\n  producer: () => T\n) => {\n  return getMesh(scene, name, () => {\n    const rootMesh = getMesh(scene, rootName, producer);\n    Asserts.assertValue(rootMesh, () => {\n      console.log({ scene, name, rootName, producer });\n      return \"Unable to create mesh instance. Missing root mesh.\";\n    });\n    return rootMesh.createInstance(name);\n  });\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { getMeshAsync } from \"./getMeshAsync\";\n\nexport const getMeshInstanceAsync = async <T extends Mesh>(\n  scene: Scene,\n  name: string,\n  rootName: string,\n  producer: () => Promise<T>\n) => {\n  return getMeshAsync(scene, name, async () => {\n    const rootMesh = await getMeshAsync(scene, rootName, producer);\n    Asserts.assertValue(rootMesh, () => {\n      console.log({ scene, name, rootName, producer });\n      return \"Unable to create mesh instance. Missing root mesh.\";\n    });\n    return rootMesh.createInstance(name);\n  });\n};\n","import { Mesh } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getPlane = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      width: number;\n      height: number;\n      tag: string | string[];\n      billboard: boolean;\n      doubleSided: boolean;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { width = 1, height = 1, tag, doubleSided  } = options;\n    const mesh = MeshBuilder.CreatePlane(\n      name,\n      {\n        width,\n        height,\n        sideOrientation: doubleSided ? Mesh.DOUBLESIDE : undefined,\n      },\n      scene\n    );\n    const { billboard } = options;\n    if (billboard) {\n      mesh.billboardMode = Mesh.BILLBOARDMODE_ALL;\n    }\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getTorusKnot = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      radius: number;\n      material: string;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { radius = 0.5 } = options;\n    const mesh = MeshBuilder.CreateTorusKnot(name, { radius }, scene);\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport type { Point3} from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\nimport { tuple2, tuple3 } from \"@mjt-engine/object\";\n\nexport type Point3ColorIndex = [Point3, number];\n\nexport const voxDataToCorrectedPoints = (voxData: VoxData) => {\n  const { XYZI, SIZE } = voxData;\n  const scale = SIZE.z;\n  const xVoxelCenterCorrection = 1 / scale / 2;\n  const yVoxelCenterCorrection = 1 / scale / 2;\n  // const zVoxelCenterCorrection = (1 / scale) * 2 + 1 / scale / 2;\n  const zVoxelCenterCorrection = 1 / scale / 2;\n  return XYZI.map((xyzi) => {\n    const [x, y, z] = toVec3(xyzi);\n\n    const xx = (x - SIZE.x / 2) / scale + xVoxelCenterCorrection;\n    const yy = (y - SIZE.y / 2) / scale + yVoxelCenterCorrection;\n\n    // TODO make +z 'up'\n    const zz = (z - SIZE.z / 2) / -scale - zVoxelCenterCorrection;\n\n    return tuple2(tuple3(xx, yy, zz), xyzi.i);\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport { SolidParticleSystem } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { c3 } from \"../bab/c3\";\nimport { c4 } from \"../bab/c4\";\nimport { v3 } from \"../bab/v3\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport { voxDataToCorrectedPoints } from \"./voxDataToCorrectedPoints\";\n\nexport const voxDataToSps = (scene: Scene, voxData: VoxData, name: string) => {\n  const { XYZI, RGBA, SIZE } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n\n  const sps = new SolidParticleSystem(name, scene);\n  const scale = 1 / SIZE.z;\n  const box = MeshBuilder.CreateBox(\"temp-box\", {\n    width: scale,\n    height: scale,\n    depth: scale,\n  });\n  sps.addShape(box, XYZI.length);\n  sps.buildMesh();\n  box.dispose();\n  voxDataToCorrectedPoints(voxData).forEach((pc, index) => {\n    const [point, colorIndex] = pc;\n    const particle = sps.particles[index];\n    particle.position = v3(point);\n\n    const color = colors[colorIndex];\n    particle.color = c4(color);\n  });\n  const material = getMaterial(scene, \"vox-material\", \"standard\");\n  // const material = Visuals.getMaterial(scene, \"vox-material\", \"pbr\");\n  // material.\n  material.specularColor = c3(\"black\");\n  sps.mesh.material = material;\n\n  sps.setParticles();\n  return sps;\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { isUndefined } from \"@mjt-engine/object\";\nimport { voxDataToSps } from \"../voxel/voxDataToSps\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getVoxModel = (\n  scene: Scene,\n  name: string,\n  src: string,\n\n  options: MeshOptions &\n    Partial<{\n      merged: boolean;\n    }> = {}\n) => {\n  // return getMesh(scene, name, () => {\n  const metadata = scene.metadata ?? {};\n  const { voxes = {} } = metadata;\n  const voxData = voxes[src];\n  if (isUndefined(voxData)) {\n    console.log({ scene, name, src });\n    throw new Error(`No voxData found for ${src} ${name}`);\n  }\n\n  const sps = voxDataToSps(scene, voxData, name);\n  const mesh = sps.mesh;\n\n  // sps.mesh.setEnabled(false);\n\n  // const { merged = true } = options;\n  // const mesh = merged\n  //   ? voxDataToMergedModel(scene, voxData, name)\n  //   : voxDataToComplexModel(scene, voxData, name);\n\n  updateMesh(scene, mesh, options);\n  return sps;\n  // });\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { InstancedMesh } from \"@babylonjs/core\";\n\nexport const isInstancedMesh = (mesh: AbstractMesh): mesh is InstancedMesh => {\n  return mesh instanceof InstancedMesh;\n};\n","import type { Point2} from \"@mjt-engine/math\";\nimport { Maths, toVec2 } from \"@mjt-engine/math\";\n\n\nexport const lookAt = (from: Point2, to: Point2) => {\n  const [x, y] = toVec2(Maths.normalize2(Maths.subtract2(to, from)));\n  return Math.atan2(y, x) + Math.PI / 2;\n};\n","import { Mesh } from \"@babylonjs/core\";\n\nexport const mergeMeshes = (\n  meshes: Mesh[],\n  options: Partial<{\n    disposeSource: boolean;\n    allow32BitsIndices: boolean;\n    meshSubclass: Mesh;\n    subdivideWithSubMeshes: boolean;\n    multiMultiMaterials: boolean;\n  }> = {}\n) => {\n  const {\n    disposeSource = false,\n    allow32BitsIndices = true,\n    meshSubclass = undefined,\n    subdivideWithSubMeshes = false,\n    multiMultiMaterials = false,\n  } = options;\n  const mergedMesh = Mesh.MergeMeshes(\n    meshes as Mesh[],\n    disposeSource,\n    allow32BitsIndices,\n    meshSubclass,\n    subdivideWithSubMeshes,\n    multiMultiMaterials\n  );\n\n  return mergedMesh;\n};\n","import type { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickMeshes = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: AbstractMesh) => boolean;\n  }> = {}\n) => {\n  const {\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n    camera = scene.activeCamera,\n  } = options;\n  if (!camera) {\n    throw new Error(\"Camera required\");\n  }\n  return scene.multiPick(x, y, predicate, camera);\n};\n","import type { PBRMaterial } from \"@babylonjs/core\";\nimport { Texture } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const describeMesh = (mesh: AbstractMesh, search = /.*/, depth = 0) => {\n  const padding = \"\".padStart(depth * 2);\n  if (search.test(mesh.name)) {\n    console.log(`${padding}mesh: '${mesh.name}'`);\n    const material = mesh.material as PBRMaterial;\n    if (isDefined(material)) {\n      const entries = Object.entries(material).filter((e) =>\n        /.Texture$/.test(e[0])\n      );\n      entries.map((entry) => {\n        const [key, value] = entry;\n        if (value instanceof Texture && key !== \"_environmentBRDFTexture\") {\n          console.log(`${padding}tex: '${value.name}' (${key})`);\n        }\n      });\n    }\n  }\n\n  mesh.getChildMeshes().map((m) => describeMesh(m, search, depth + 1));\n};\n","import { getBox } from \"./getBox\";\nimport { getBoxInstance } from \"./getBoxInstance\";\nimport { getSphere } from \"./getSphere\";\nimport { pickMesh } from \"./pickMesh\";\nimport { calcTopOfMeshWorldPosition } from \"./calcTopOfMeshWorldPosition\";\nimport { walkMeshes } from \"./walkMeshes\";\nimport { getPolyhedron } from \"./getPolyhedron\";\n\n// BS babylonjs 'magic'\n// import \"@babylonjs/core/Debug/debugLayer\";\n// import \"@babylonjs/inspector\";\n// import \"babylonjs-inspector\";\n// import \"babylonjs/Debug/debugLayer\";\n\nimport { calcClientRectForMesh } from \"./calcClientRectForMesh\";\nimport { destroyMesh } from \"./destroyMesh\";\nimport { findClosestPick } from \"./findClosestPick\";\nimport { getCylinder } from \"./getCylinder\";\nimport { getLine } from \"./getLine\";\nimport { getMesh } from \"./getMesh\";\nimport { getMeshAsync } from \"./getMeshAsync\";\nimport { getMeshInstance } from \"./getMeshInstance\";\nimport { getMeshInstanceAsync } from \"./getMeshInstanceAsync\";\nimport { getPlane } from \"./getPlane\";\nimport { getTorusKnot } from \"./getTorusKnot\";\nimport { getVoxModel } from \"./getVoxModel\";\nimport { isInstancedMesh } from \"./isInstancedMesh\";\nimport { lookAt } from \"./lookAt\";\nimport { mergeMeshes } from \"./mergeMeshes\";\nimport { pickMeshes } from \"./pickMeshes\";\nimport { updateArcRotateCameraPosition } from \"./updateArcRotateCameraPosition\";\nimport { updateMesh } from \"./updateMesh\";\nimport { describeMesh } from \"./describeMesh\";\nexport const Meshes = {\n  lookAt,\n  getBox,\n  describeMesh,\n  getPlane,\n  getBoxInstance,\n  getSphere,\n  getCylinder,\n  getTorusKnot,\n  getLine,\n  walkMeshes,\n  pickMesh,\n  getMesh,\n  getMeshAsync,\n  calcTopOfMeshWorldPosition,\n  mergeMeshes,\n  getVoxModel,\n  calcClientRectForMesh,\n  updateArcRotateCameraPosition,\n  findClosestPick,\n  destroyMesh,\n  getMeshInstance,\n  getMeshInstanceAsync,\n  isInstancedMesh,\n  pickMeshes,\n  getPolyhedron,\n  updateMesh,\n};\n","import { Scene } from \"@babylonjs/core\";\nimport { Cameras } from \"../camera/Cameras\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { Lights } from \"../light/Lights\";\nimport { Meshes } from \"../mesh/Meshes\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const helloWorld = (engine: BabEngine = createWebGlEngine()) => {\n  const scene = new Scene(engine);\n  const canvas = engine.getRenderingCanvas();\n\n  const camera = Cameras.getArcRotateCamera(scene, \"Camera\", {});\n  camera.attachControl(canvas, true);\n  Lights.getHemisphericLight(scene, \"light1\", {\n    direction: [1, 1, 1],\n  });\n  Meshes.getSphere(scene, \"sphere\", {\n    radius: 0.5,\n  });\n  // hide/show the Inspector\n  const STATE = { debug: false };\n  canvas!.onkeyup = (ev) => {\n    // ctrl+I\n    if (ev.ctrlKey && ev.keyCode === 73) {\n      STATE.debug = !STATE.debug;\n      if (STATE.debug) {\n        scene.debugLayer.hide();\n      } else {\n        console.log(\"SHOW!\");\n        scene.debugLayer.show();\n      }\n    }\n  };\n\n  // run the main render loop\n  engine.runRenderLoop(() => {\n    scene.render();\n  });\n  return scene;\n};\n","import { attachArcRotateCameraControls } from \"../camera/attachArcRotateCameraControls\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { helloVrWorld } from \"../vr/hellowVrWorld\";\nimport { c3 } from \"./c3\";\nimport { c4 } from \"./c4\";\nimport { createCanvas } from \"./createCanvas\";\nimport { helloWorld } from \"./helloWorld\";\nimport { v3 } from \"./v3\";\n\nexport const Babs = {\n  createEngine: createWebGlEngine,\n  createCanvas,\n  v3,\n  c3,\n  c4,\n  helloWorld,\n  helloVrWorld,\n  attachEditorControls: attachArcRotateCameraControls,\n};\n","import { WebGPUEngine, WebGPUEngineOptions } from \"@babylonjs/core\";\n\nexport const createWebGpuEngine = async ({\n  canvas,\n  ...rest\n}: { canvas: HTMLCanvasElement | OffscreenCanvas } & WebGPUEngineOptions) => {\n  const engine = new WebGPUEngine(canvas, {\n    // powerPreference: \"high-performance\",\n    ...rest,\n  });\n  engine.hideLoadingUI();\n  await engine.initAsync();\n  return engine;\n};\n","import { WebGPUEngine } from \"@babylonjs/core\";\n\n\nexport const isWebGpuCapable = () => {\n  return WebGPUEngine.IsSupportedAsync;\n};\n","import { createWebGlEngine } from \"./createWebglEngine\";\nimport { createWebGpuEngine } from \"./createWebGpuEngine\";\nimport { isWebGpuCapable } from \"./isWebGpuCapable\";\n\nexport const Engines = {\n  createWebGlEngine,\n  createWebGpuEngine,\n  isWebGpuCapable,\n};\n","import { isDefined, isUndefined } from \"@mjt-engine/object\";\n\nlet depth = 0;\n\nconst STYLE = \"background: #222; color: #bada55\";\nexport const enabled = false;\nexport const stopwatch = (label: string) => {\n  const padding = \"\".padStart(depth * 2);\n  depth += 1;\n  label = padding + label;\n  if (enabled) {\n    console.log(`%c${label} start`, STYLE);\n  }\n\n  const start = Date.now();\n\n  return (checkpoint?: string) => {\n    const time = Date.now() - start;\n    const labelCheckpoint = [label, checkpoint ?? \"\"].join(\" \");\n    if (enabled) {\n      console.log(`%c${labelCheckpoint} ${(time / 1000).toFixed(2)}`, STYLE);\n      if (isUndefined(checkpoint)) {\n        depth -= 1;\n      }\n    }\n  };\n};\n\n// export function time<T>(expr: () => T, label: string): T;\n// export async function time<T>(\n//   expr: () => Promise<T>,\n//   label: string\n// ): Promise<T>;\n\nexport function time<T>(expr: () => T, label = expr.name): T {\n  const sw = stopwatch(label);\n  const result = expr();\n  sw();\n  return result;\n}\n\nexport async function timeP<T>(\n  expr: () => Promise<T>,\n  label = expr.name\n): Promise<T> {\n  const sw = stopwatch(label);\n  const result = await expr();\n  sw();\n  return result;\n}\n\nexport const Timers = {\n  time,\n  timeP,\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { stopwatch } from \"../util/Timers\";\n\nexport const renderOnce = (scene: Scene): Promise<void> => {\n  const sw = stopwatch(`renderOnce`);\n  return new Promise((resolve, reject) => {\n    try {\n      scene.onAfterRenderCameraObservable.addOnce(() => {\n        sw();\n        resolve();\n      });\n      scene.render(true);\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import { Color3 } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { ModelMaterial } from \"../ModelBuilder\";\n\nexport const fixEyelashes = (scene: Scene) => {\n  console.log(\"fixing eyelashes\", scene.meshes);\n  scene.meshes.forEach((mesh) => {\n    if (mesh.name.includes(\"Eyelashes\")) {\n      console.log(\"fixing eyelashes\", mesh.name);\n      // mesh.setEnabled(false); // TODO re-enable eyelashes when morphs fixed\n      if (mesh.name.includes(\"primitive1\")) {\n        console.log(\"fixing eyelashes: primitive1\", mesh.name);\n        const material = mesh.material as ModelMaterial;\n        if (!material) {\n          throw new Error(\"Mesh has no material\", { cause: mesh });\n        }\n        const texture = material.getActiveTextures()[0];\n        texture.hasAlpha = true;\n        texture.getAlphaFromRGB = true;\n        material.transparencyMode = 1;\n        material.opacityTexture = texture;\n        mesh.visibility = 0.5;\n        material.albedoColor = new Color3(0, 0, 0);\n      }\n    }\n  });\n};\n","import type { PBRMaterial } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nexport const HIDE = [\n  // \"Irises\",\n  // \"Pupils\",\n  // \"Sclera\", // 'red' of the eye\n  // \"Cornea\",\n  // \"Eyelashes\",\n  // \"EyeMoisture\",\n  // \"EyeSocket\",\n  // \"Face\",\n  // \"Teeth\",\n  // \"Lips\",\n  // \"Mouth\",\n  // \"Ears\",\n  // \"Torso\",\n];\n\nexport const GLOSS = [\n  \"Irises\",\n  \"Pupils\",\n  \"Sclera\",\n  // \"Eyelashes\",\n  // \"EyeSocket\",\n  // \"Face\",\n  // \"Teeth\",\n  // \"Lips\",\n  // \"Mouth\",\n  // \"Ears\",\n  // \"Torso\",\n];\n\nexport const fixEyes = (mesh: AbstractMesh) => {\n  // console.log(mesh.name);\n  const textures = mesh?.material?.getActiveTextures() ?? [];\n  // textures.map((t) => console.log(\"texture: \" + t?.name));\n  if (\n    isDefined(\n      textures.find((t) => {\n        const name = t?.name;\n        return isDefined(HIDE.find((h) => name.includes(h)));\n      })\n    )\n  ) {\n    mesh.visibility = 0;\n  }\n\n  // gloss meshes\n  if (\n    isDefined(\n      textures.find((t) => {\n        const name = t?.name;\n        return isDefined(GLOSS.find((h) => name.includes(h)));\n      })\n    )\n  ) {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 1;\n    material.transparencyMode = 2;\n\n    // material.subSurface.isScatteringEnabled = true;\n    // material.subSurface.scatteringDiffusionProfile = c3(\"white\");\n    // material.albedoTexture.hasAlpha = true;\n    // material.roughness = 0.5;\n    // material.albedoColor = c3('green')\n    // material.emissiveIntensity = 1;\n    // material.emissiveColor = c3(\"white\");\n    // material.emissiveTexture = material.albedoTexture;\n    // material.roughness = 0;\n    if (material.albedoTexture) {\n      material.albedoTexture.hasAlpha = true;\n    }\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.2;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    material.opacityTexture = material.albedoTexture;\n    // mesh.visibility = 0;\n    // material.emissiveTexture = material.albedoTexture;\n    // material.albedoColor = c3(\"red\");\n  }\n\n  // moisture?\n  if (mesh.name === \"Genesis8Female.Shape_primitive10\") {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 0;\n    mesh.visibility = 0;\n    // // material.zOffset = -1;\n    // // material.roughness = 0.5;\n    // // material.clearCoat.isEnabled = true;\n    // // material.clearCoat.intensity = 1;\n    // // material.useLogarithmicDepth = true;\n\n    // // material.subSurface.isScatteringEnabled = true;\n    // // material.subSurface.scatteringDiffusionProfile = c3(\"grey\");\n\n    // material.transparencyMode = 2;\n    // material.clearCoat.isEnabled = true;\n    // material.clearCoat.intensity = 0.3;\n    // material.subSurface.isTranslucencyEnabled = true;\n    // material.subSurface.translucencyIntensity = 1;\n    // material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // // material.albedoTexture.hasAlpha = true;\n\n    // // visibility controls the 'redness' of the eyes\n    // mesh.visibility = 0.4;\n    // // mesh.setEnabled(false);\n  }\n\n  // pupil mask (water layer)\n  if (mesh.name === \"Genesis8Female.Shape_primitive12\") {\n    const material = mesh.material as PBRMaterial;\n    // material.metallic = 1;\n    material.roughness = 0;\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.5;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // can have the 'effect' of clouding/ disapering the iris/pupil\n    mesh.visibility = 0;\n    mesh.setEnabled(false);\n    // mesh.visibility = 1;\n  }\n\n  // iris\n  if (mesh.name === \"Genesis8Female.Shape_primitive13\") {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 0;\n  }\n\n  // sclarera\n  if (mesh.name === \"Genesis8Female.Shape_primitive14\") {\n    const material = mesh.material as PBRMaterial;\n    material.opacityTexture = null;\n    material.metallic = 0;\n    material.useAlphaFromAlbedoTexture = false;\n    if (material.albedoTexture) {\n      material.albedoTexture.level = 3;\n    }\n  }\n  // bottom edge of eyelid\n  if (mesh.name.endsWith(\"Eyelashes.Shape_primitive0\")) {\n    const material = mesh.material as PBRMaterial;\n    // material.metallic = 1;\n    material.roughness = 0.5;\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.5;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // material.albedoColor = new Color3(0.5, 0.5, 0.5);\n    mesh.visibility = 0.2;\n    // mesh.visibility = 0.5;\n    // mesh.visibility = 0.5;\n  }\n\n  mesh.getChildMeshes().map(fixEyes);\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport type { ModelMaterial } from \"../ModelBuilder\";\n\nexport const fixBumpMaps = (scene: Scene) => {\n  console.log(\"fixing bump maps\", scene.meshes);\n  scene.meshes.forEach((mesh) => {\n    // mesh.setEnabled(false); // TODO re-enable eyelashes when morphs fixed\n    const material = mesh.material as ModelMaterial;\n    if (!material) {\n      return;\n    }\n    material.bumpTexture = null;\n  });\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { fixEyelashes } from \"./fixEyelashes\";\nimport { fixEyes } from \"./fixEyes\";\nimport { fixBumpMaps } from \"./fixBumpMaps\";\n\nexport const fixDazFigure = (scene: Scene) => {\n  fixEyelashes(scene);\n  scene.meshes.map(fixEyes);\n  fixBumpMaps(scene);\n};\n","import { SceneLoader } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n// import { GLTF2 } from \"@babylonjs/loaders/glTF\";\nimport { fixDazFigure } from \"./fix/fixDazFigure\";\n\n/** WARNING!!!!!!\n * \n * YOU MUST LOAD THE GLTF2 LOADER FIRST!!!\n * import { GLTF2 } from \"@babylonjs/loaders/glTF\";\n * \n */\nexport const loadDazFigure = (props: {\n  path: string | File;\n  scene: Scene;\n  name?: string;\n}): Promise<AbstractMesh> => {\n  const { path, scene, name = path instanceof File ? path.name : path } = props;\n  const engine = scene.getEngine();\n  engine.hideLoadingUI();\n\n  return new Promise((resolve, reject) => {\n    try {\n      // GLTF2.GLTFLoader; // fucking loader 'magic'\n      SceneLoader.ShowLoadingScreen = false;\n\n      SceneLoader.Append(\n        \"\",\n        path,\n        scene,\n        (loadedScene) => {\n          const rootMesh = loadedScene.getMeshByName(\"__root__\");\n          if (!rootMesh) {\n            throw new Error(\"No root mesh found\", { cause: loadedScene });\n          }\n          rootMesh.name = name;\n          if (loadedScene.cameras.length > 0) {\n            loadedScene.activeCamera = loadedScene.cameras[0];\n          }\n          loadedScene.animationGroups.forEach((anim) => {\n            anim.stop();\n          });\n          fixDazFigure(loadedScene);\n\n          resolve(rootMesh);\n        },\n        (progress) => {},\n        (scene, message, reason) => {\n          console.log({ path, scene, message, reason });\n          reject(reason);\n        }\n      );\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import { renderOnce } from \"../scene/renderOnce\";\nimport { builder } from \"./builder\";\nimport { fixDazFigure } from \"./fix/fixDazFigure\";\nimport { loadAssetContainer } from \"./loadAssetContainer\";\nimport { loadDazFigure } from \"./loadDazFigure\";\n\nexport const Models = {\n  renderOnce,\n  loadDazFigure,\n  // fixDazFigure,\n  // loadAssetContainer,\n  // builder,\n};\n","export const copyToCanvas = (\n  image: HTMLCanvasElement | OffscreenCanvas | HTMLImageElement,\n  width = image.width,\n  height = image.height\n) => {\n  const copy = document.createElement(\"canvas\");\n  copy.width = width;\n  copy.height = height;\n  copy\n    .getContext(\"2d\")!\n    .drawImage(\n      image as HTMLCanvasElement,\n      0,\n      0,\n      image.width,\n      image.height,\n      0,\n      0,\n      copy.width,\n      copy.height\n    );\n  return copy;\n};\n","import { Images } from \"@mjt-engine/image\";\nimport type { TextureImageSrc } from \"../texture/TextureImageSrc\";\nimport { stopwatch } from \"./Timers\";\n\nexport const imageSrcToUrl = async (src: TextureImageSrc): Promise<string> => {\n  const sw = stopwatch(\"imageSrcToUrl\");\n  if (typeof src === \"string\") {\n    sw();\n    return src;\n  }\n\n  // const flipped = await createImageBitmap(src, {\n  //   imageOrientation: \"flipY\",\n  // });\n  const cvs = document.createElement(\"canvas\");\n  cvs.width = src.width;\n  cvs.height = src.height;\n  cvs.getContext(\"2d\")!.drawImage(src, 0, 0);\n  const result = await Images.toSrcString(cvs);\n  sw();\n  return result;\n};\n","import { DynamicTexture } from \"@babylonjs/core\";\nimport { Texture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { imageSrcToUrl } from \"../util/imageSrcToUrl\";\n\nexport const imageToTexture = async (\n  scene: Scene,\n  name: string,\n  image: string | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas\n): Promise<Texture> => {\n  if (image instanceof HTMLCanvasElement) {\n    return new Promise((resolve, reject) => {\n      try {\n        const texture = new DynamicTexture(name, image, scene);\n        texture.update();\n        texture.hasAlpha = true;\n        resolve(texture);\n      } catch (reason) {\n        reject(reason);\n      }\n    });\n  }\n\n  const url = await imageSrcToUrl(image);\n  return new Promise((resolve, reject) => {\n    try {\n      const texture = new Texture(url, scene, false, true);\n      texture.name = name;\n      texture.hasAlpha = true;\n      texture.onLoadObservable.addOnce(() => {\n        resolve(texture);\n      });\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import { StandardMaterial } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { Randoms } from \"@mjt-engine/random\";\nimport { c3 } from \"../bab/c3\";\nimport type { TextureImageSrc } from \"./TextureImageSrc\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { imageToTexture } from \"./imageToTexture\";\n\nexport const hasValidId = (obj: { id: string | number } | string) => {\n  if (typeof obj === \"string\") {\n    return true;\n  }\n  return isDefined(obj.id) && String(obj.id).startsWith(\"id-\");\n};\n\nexport const idOfImageSrc = (src: TextureImageSrc) => {\n  if (typeof src === \"string\") {\n    return src;\n  }\n  if (\"id\" in src) {\n    return src.id;\n  }\n  return undefined;\n};\n\nexport const layerToPlane = async (layer: TextureLayer, scene: Scene) => {\n  const id = Randoms.randomUuid();\n  const { size, image, color } = layer;\n  const plane = MeshBuilder.CreatePlane(\n    `plane-${id}`,\n    {\n      width: size,\n      height: size,\n    },\n    scene\n  );\n  const material = new StandardMaterial(`material-${id}`, scene);\n  if (isDefined(image)) {\n    const texture = await imageToTexture(scene, `layer-${id}`, image);\n    layer._texture = texture;\n    layer._mesh = plane;\n    layer._material = material;\n\n    texture.hasAlpha = true;\n    material.opacityTexture = texture;\n    material.emissiveTexture = texture;\n  }\n\n  if (isDefined(color)) {\n    material.emissiveColor = c3(color);\n  }\n\n  plane.material = material;\n  return plane;\n};\n","import type { Engine } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { layerToPlane } from \"./layerToPlane\";\n\nexport const imageLayersToScene = async (\n  layers: TextureLayer[],\n  engine: Engine\n) => {\n  const scene = new Scene(engine);\n  const planes = await Promise.all(\n    layers.map(async (image, index) => {\n      const plane = await layerToPlane(image, scene);\n      plane.position.set(0, 0, -index);\n      return plane;\n    })\n  );\n  return scene;\n};\n","import { Camera } from \"@babylonjs/core\";\nimport { UniversalCamera } from \"@babylonjs/core\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { renderOnce } from \"../scene/renderOnce\";\nimport { v3 } from \"../bab/v3\";\nimport { timeP } from \"../util/Timers\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { copyToCanvas } from \"./copyToCanvas\";\nimport { imageLayersToScene } from \"./imageLayersToScene\";\n\nexport const builder = ({ size } = { size: 4096 }): TextureBuilder => {\n  const engine = createWebGlEngine({ width: size, height: size });\n  const canvas = engine.getRenderingCanvas();\n  const STATE = {\n    layers: [] as TextureLayer[],\n  };\n  const b: TextureBuilder = {\n    addLayer: (layer) => {\n      STATE.layers.push({ size, ...layer });\n      return b;\n    },\n    render: async () => {\n      return timeP(async () => {\n        const scene = await imageLayersToScene(STATE.layers, engine);\n        const camera = new UniversalCamera(\"camera1\", v3(0, 0, -1000), scene);\n        camera.setTarget(v3());\n        camera.rotation = v3(0, 0, Math.PI);\n        camera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n        camera.minZ = 0;\n        camera.maxZ = 100000;\n\n        await renderOnce(scene);\n        b.clear();\n        if (!canvas) {\n          throw new Error(\"No canvas found\", { cause: engine });\n        }\n        return copyToCanvas(canvas);\n      }, \"Texture render\");\n    },\n    clear: () => {\n      STATE.layers.forEach((layer) => {\n        if (layer?._cached) {\n          return;\n        }\n        layer?._texture?.dispose();\n        layer?._mesh?.dispose();\n        layer?._material?.dispose();\n      });\n      STATE.layers.length = 0;\n      return b;\n    },\n  };\n\n  return b;\n};\n\nexport type TextureBuilder = {\n  addLayer: (layer: TextureLayer) => TextureBuilder;\n  render: () => Promise<HTMLCanvasElement | OffscreenCanvas>;\n  clear: () => TextureBuilder;\n};\n","import type { ICanvasRenderingContext } from \"@babylonjs/core/Engines/ICanvas\";\nimport type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\n\nexport const drawOnTexture = (\n  texture: DynamicTexture,\n  render: (\n    ctx: ICanvasRenderingContext,\n    size: { width: number; height: number }\n  ) => void\n) => {\n  const size = texture.getSize();\n  const ctx = texture.getContext();\n  render(ctx, size);\n  texture.update();\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { drawOnTexture } from \"./drawOnTexture\";\n\nexport const clearTexture = (texture: DynamicTexture) => {\n  drawOnTexture(texture, (ctx, size) => {\n    const { width, height } = size;\n    ctx.clearRect(0, 0, width, height);\n  });\n};\n","import { Textures } from \"./Textures\";\n\nexport const debugImage = (\n  image: HTMLCanvasElement | HTMLImageElement,\n  label = \"DEBUG IMAGE\"\n) => {\n  // const canvas = document.createElement(\"canvas\");\n  const canvas = Textures.copyToCanvas(image, 1024, 1024);\n  // canvas.style.position = \"absolute\";\n  // canvas.style.left = \"0\";\n  // canvas.style.top = \"0\";\n  canvas.style.border = \"1px solid grey\";\n  const labelElement = document.createElement(\"div\");\n  labelElement.textContent = label;\n\n  document.body.appendChild(labelElement);\n  document.body.appendChild(canvas);\n  return new Promise((resolve, reject) => {\n    const onclick = () => {\n      canvas.remove();\n      labelElement.remove();\n      resolve(undefined);\n    };\n    canvas.onclick = onclick;\n    labelElement.onclick = onclick;\n  });\n};\n","import type { Scene } from \"@babylonjs/core\";\n\nexport const destroyTexture = (scene: Scene, name: string) => {\n  const tex = scene.getTextureByName(name);\n  if (!tex) {\n    return;\n  }\n  tex.dispose();\n  scene.removeTexture(tex);\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { Colors } from \"@mjt-engine/color\";\nimport { drawOnTexture } from \"./drawOnTexture\";\n\nexport const drawBackgroundOnTexture = (\n  texture: DynamicTexture,\n  options: Partial<{\n    color: string;\n  }> = {}\n) => {\n  const { color = \"black\" } = options;\n  drawOnTexture(texture, (ctx, size) => {\n    const { width, height } = size;\n    ctx.fillStyle = Colors.from(color).toString();\n    ctx.fillRect(0, 0, width, height);\n  });\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const drawTextOnTexture = (\n  texture: DynamicTexture,\n  text: string,\n\n  options: Partial<{\n    color: string;\n    outline: boolean;\n    outlineColor: string;\n    backgroundColor: string;\n    text: string;\n    textureSize: number;\n    textScale: number;\n    rotation: Point3;\n    fontFamily: string;\n    fontStyle: string;\n  }> = {}\n) => {\n  const {\n    backgroundColor,\n    outline = true,\n    color = \"black\",\n    fontFamily = \"monospace\",\n    fontStyle = \"bold\",\n    outlineColor = Colors.builder({ color: \"white\" }).alpha(0.1).toString(),\n    textureSize = Math.min(texture.getSize().width, texture.getSize().height),\n  } = options;\n  texture.hasAlpha = true;\n  let fontSize = textureSize;\n  let font = `${fontStyle} ${fontSize}px ${fontFamily}`;\n  const ctx = texture.getContext();\n\n  ctx.font = font;\n  let measure = ctx.measureText(text);\n  fontSize = (textureSize / measure.width) * textureSize;\n  font = `${fontStyle} ${fontSize}px ${fontFamily}`;\n  ctx.font = font;\n  const textX = 0;\n  measure = ctx.measureText(text);\n  /** @ts-ignore */\n  const top = measure[\"fontBoundingBoxAscent\"] ?? 0;\n  const textY = textureSize - (textureSize - top) / 2;\n  ctx.lineWidth = fontSize / 2;\n\n  const bbox = {\n    x: 0,\n    y: textY - fontSize,\n    width: textureSize,\n    height: top * 2,\n  };\n  if (isDefined(backgroundColor)) {\n    ctx.fillStyle = Colors.from(backgroundColor).toString();\n    const { x, y, width, height } = bbox;\n    // ctx.fillRect(0, textY - fontSize, textureSize, top * 2);\n    ctx.fillRect(x, y, width, height);\n  }\n  if (outline) {\n    ctx.strokeStyle = outlineColor;\n    ctx.strokeText(text, textX, textY);\n  }\n  ctx.fillStyle = color;\n  ctx.fillText(text, textX, textY);\n\n  texture.hasAlpha = true;\n  texture.update();\n  return bbox;\n};\n","import { Texture } from \"@babylonjs/core\";\n\nexport const TEXTURE_SAMPLING_MODES = {\n  linearNearest: Texture.LINEAR_NEAREST,\n  nearestNearest: Texture.NEAREST_NEAREST,\n  linearLinear: Texture.LINEAR_LINEAR,\n  nearestLinear: Texture.NEAREST_LINEAR,\n};\n","import type { BaseTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getTexture = <T extends BaseTexture>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const texture = scene.getTextureByName(name);\n  if (isDefined(texture)) {\n    return texture as T;\n  }\n  return producer();\n};\n","import type { BaseTexture } from \"@babylonjs/core\";\nimport { DynamicTexture } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport type { AllTextureOptions } from \"./Textures\";\n\nexport const updateTexture = (\n  texture: BaseTexture,\n  options: AllTextureOptions\n) => {\n  const { hasAlpha } = options;\n  iff(hasAlpha, (value) => {\n    texture.hasAlpha = value;\n  });\n\n  if (texture instanceof DynamicTexture) {\n    texture.update();\n  }\n};\n","import { DynamicTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport type { DynamicTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getDynamicTexture = (\n  scene: Scene,\n  name: string,\n  options: DynamicTextureOptions = {}\n) => {\n  const texture = getTexture(scene, name, () => {\n    const {\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n      width = 1024,\n      height = 1024,\n      init,\n    } = options;\n    const result = new DynamicTexture(\n      name,\n      {\n        width,\n        height,\n      },\n      scene,\n      generateMipMaps,\n      TEXTURE_SAMPLING_MODES[samplingMode]\n    );\n    if (init) {\n      init(result.getContext());\n      result.update();\n    }\n    return result;\n  });\n  updateTexture(texture, options);\n  return texture;\n};\n","import { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport type { TextureSamplingModeMap } from \"./Textures\";\n\n\nexport const samplingModeNumber = (\n  name: keyof TextureSamplingModeMap\n): number => {\n  return TEXTURE_SAMPLING_MODES[name];\n};\n","import { HtmlElementTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { HtmlElementTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { samplingModeNumber } from \"./samplingModeNumber\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getHtmlElementTexture = (\n  scene: Scene,\n  name: string,\n  options: HtmlElementTextureOptions\n) => {\n  return getTexture(scene, name, () => {\n    const {\n      element,\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n    } = options;\n    if (!element) {\n      throw new Error(\"HTML element is required to create texture\", {\n        cause: options,\n      });\n    }\n    const texture = new HtmlElementTexture(name, element, {\n      generateMipMaps,\n      samplingMode: samplingModeNumber(samplingMode),\n      engine: scene.getEngine(),\n      scene,\n    });\n    updateTexture(texture, options);\n    return texture;\n  });\n};\n","import { Texture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { PathTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { samplingModeNumber } from \"./samplingModeNumber\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getPathTexture = (\n  scene: Scene,\n  name: string,\n  options: PathTextureOptions\n) => {\n  const texture = getTexture(scene, name, () => {\n    const {\n      src,\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n    } = options;\n    if (!src) {\n      throw new Error(\"src is required\", { cause: options });\n    }\n    const texture = new Texture(src, scene, {\n      samplingMode: samplingModeNumber(samplingMode),\n    });\n    texture.name = name;\n    return texture;\n  });\n\n  updateTexture(texture, options);\n  return texture;\n};\n","import type { ICanvasRenderingContext } from \"@babylonjs/core\";\nimport type { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport { builder } from \"./builder\";\nimport { clearTexture } from \"./clearTexture\";\nimport { copyToCanvas } from \"./copyToCanvas\";\nimport { debugImage } from \"./debugImage\";\nimport { destroyTexture } from \"./destroyTexture\";\nimport { drawBackgroundOnTexture } from \"./drawBackgroundOnTexture\";\nimport { drawOnTexture } from \"./drawOnTexture\";\nimport { drawTextOnTexture } from \"./drawTextOnTexture\";\nimport { getDynamicTexture } from \"./getDynamicTexture\";\nimport { getHtmlElementTexture } from \"./getHtmlElementTexture\";\nimport { getPathTexture } from \"./getPathTexture\";\nimport { getTexture } from \"./getTexture\";\nimport { imageToTexture } from \"./imageToTexture\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport type TextureSamplingModeMap = typeof TEXTURE_SAMPLING_MODES;\n\nexport type TextureOptions = Partial<{\n  hasAlpha: boolean;\n  generateMipMaps: boolean;\n  samplingMode: keyof TextureSamplingModeMap;\n}>;\n\nexport type HtmlElementTextureOptions = Partial<\n  TextureOptions & {\n    element: HTMLCanvasElement | HTMLVideoElement;\n  }\n>;\n\nexport type PathTextureOptions = Partial<\n  TextureOptions & {\n    src: string;\n  }\n>;\n\nexport type DynamicTextureOptions = Partial<\n  TextureOptions & {\n    width: number;\n    height: number;\n    init: (ctx: ICanvasRenderingContext) => void;\n  }\n>;\n\nexport type AllTextureOptions = HtmlElementTextureOptions &\n  DynamicTextureOptions;\n\nexport const Textures = {\n  builder,\n  copyToCanvas,\n  debugImage,\n  getTexture,\n  getHtmlElementTexture,\n  getDynamicTexture,\n  getPathTexture,\n  updateTexture,\n\n  imageToTexture,\n\n  drawTextOnTexture,\n  drawOnTexture,\n  drawBackgroundOnTexture,\n  clearTexture,\n  destroyTexture,\n};\n","import {\n  GlowLayer,\n  type IGlowLayerOptions,\n} from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getGlowLayer = (\n  scene: Scene,\n  name: string,\n  options?: IGlowLayerOptions\n) => {\n  // workaround Bug in getGlowlayerbyName\n  const layerMaybe = scene?.effectLayers?.length\n    ? scene.getGlowLayerByName(name)\n    : undefined;\n  if (isDefined(layerMaybe)) {\n    return layerMaybe;\n  }\n  return new GlowLayer(name, scene, options);\n};\n","import type { IHighlightLayerOptions } from \"@babylonjs/core\";\nimport { HighlightLayer } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getHighlightLayer = <T extends HighlightLayer>(\n  scene: Scene,\n  name: string,\n  options?: IHighlightLayerOptions\n) => {\n  const layerMaybe = scene.getHighlightLayerByName(name);\n  if (isDefined(layerMaybe)) {\n    return layerMaybe;\n  }\n  return new HighlightLayer(name, scene, options);\n};\n","import { getGlowLayer } from \"./getGlowLayer\";\nimport { getHighlightLayer } from \"./getHighlightLayer\";\n\nexport const Layers = {\n  getGlowLayer,\n  getHighlightLayer,\n};\n","import { getMaterial } from \"./getMaterial\";\nimport type { MaterialTypeMap } from \"./MaterialTypeMap\";\nimport { updateMaterial } from \"./updateMaterial\";\nimport { updateStandardMaterial } from \"./updateStandardMaterial\";\n\nexport type MaterialOptions = Partial<{\n  type: keyof MaterialTypeMap;\n}>;\n\nexport type StandardMaterialOptions = Partial<\n  MaterialOptions & {\n    diffuseTexture: string;\n    emissiveTexture: string;\n    ambientTexture: string;\n    opacityTexture: string;\n    diffuseColor: string;\n    alpha: number;\n    specularColor: string;\n    ambientColor: string;\n    emissiveColor: string;\n  }\n>;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type PbrMaterialOptions = Partial<{}>;\nexport type AllMaterialOptions = StandardMaterialOptions & PbrMaterialOptions;\n\nexport const Materials = {\n  getMaterial,\n  updateMaterial,\n  updateStandardMaterial,\n};\n","import { TransformNode } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getTransformNode = (scene: Scene, name: string): TransformNode => {\n  const node = scene.getTransformNodeByName(name);\n  if (isDefined(node)) {\n    return node;\n  }\n  return new TransformNode(name, scene);\n};\n","import { getTransformNode } from \"./getTransformNode\";\n\nexport const Nodes = {\n  getTransformNode,\n};\n","import { type Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { BabScene } from \"../type/BabScene\";\nimport { BabParticleSystem } from \"../type/BabParticleSystem\";\n\nexport const getSolidParticleSystemsMetadata = (\n  scene: BabScene\n): Record<string, BabParticleSystem> => {\n  const metadata = scene.metadata ?? {};\n  const spsMetadata = metadata[\"solidParticleSystems\"] ?? {};\n\n  if (isDefined(spsMetadata)) {\n    return spsMetadata;\n  }\n  scene.metadata = {\n    ...metadata,\n    solidParticleSystems: {},\n  };\n\n  return spsMetadata;\n};\n\nexport const getParticleSystem = <T extends BabParticleSystem>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n): T => {\n  const spsMetadata = getSolidParticleSystemsMetadata(scene);\n  const spsMaybe = spsMetadata[name];\n\n  if (isDefined(spsMaybe)) {\n    spsMaybe as T;\n  }\n  const result = producer();\n  spsMetadata[name] = result;\n  return result;\n};\n","import { SolidParticleSystem } from \"@babylonjs/core\";\nimport { BabScene } from \"../type/BabScene\";\nimport { getParticleSystem } from \"./getParticleSystem\";\n\nexport const getSolidParticleSystem = (\n  scene: BabScene,\n  name: string,\n  options: ConstructorParameters<typeof SolidParticleSystem>[2]\n): SolidParticleSystem => {\n  return getParticleSystem(scene, name, () => {\n    return new SolidParticleSystem(name, scene, {\n      ...options,\n    });\n  });\n};\n","import {\n  Mesh as BabMesh,\n  Scene as BabScene,\n  SolidParticle as BabSolidParticle,\n  SolidParticleSystem as BabSolidParticleSystem,\n  Color4,\n  SolidParticleSystem,\n  StandardMaterial,\n} from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { Materials } from \"../material/Materials\";\nimport { getSolidParticleSystem } from \"./getSolidParticleSystem\";\n\nexport type Sps = {\n  scene: BabScene;\n  getSystem: () => BabSolidParticleSystem;\n  dispose: () => void;\n  getInstance: () => BabSolidParticleSystem;\n  rebuild: () => void;\n  update: () => void;\n  addMesh: (mesh: BabMesh, count?: number) => void;\n  removeMesh: (mesh: BabMesh) => void;\n  syncParticlestoMeshes: () => void;\n  hasMesh: (meshName: string) => boolean;\n  updateParticlesByName: (\n    name: string,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  updateParticleByIndex: (\n    index: number,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  updateNextParticle: (\n    name: string,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  clearParticles: () => void;\n  getNames: () => Iterable<string>;\n};\n\nexport const Sps = (\n  scene: BabScene,\n  name: string,\n  options: Partial<{ material: string; onMeshBuild: (mesh: BabMesh) => void }> &\n    Parameters<typeof getSolidParticleSystem>[2] = {}\n): Sps => {\n  const nextIndexMap = new Map<string, number>();\n  const meshToCounts = new Map<BabMesh, number>();\n  const meshToParticleIndexes = new Map<BabMesh, number[]>();\n  const meshNameToParticleIndexes = new Map<string, number[]>();\n  const meshNameToMesh = new Map<string, BabMesh>();\n  const { material, onMeshBuild, ...rest } = options;\n\n  let system: BabSolidParticleSystem;\n\n  const renewSps = () => {\n    system?.mesh?.dispose(false);\n    system = new SolidParticleSystem(name, scene, {\n      ...rest,\n    });\n  };\n\n  renewSps();\n\n  const mod: Sps = {\n    scene,\n    clearParticles: () => {\n      system.particles.forEach((p, i) => {\n        p.color = TRANSPARENT_COLOR;\n      });\n      system.setParticles();\n      system.particles.forEach((p, i) => {\n        p.alive = false;\n      });\n    },\n    getSystem: () => {\n      return system;\n    },\n    getNames: () => {\n      return meshNameToParticleIndexes.keys();\n    },\n    hasMesh: (meshName: string) => {\n      return meshNameToParticleIndexes.has(meshName);\n    },\n    getInstance: () => {\n      return system;\n    },\n    updateNextParticle: (name, fn) => {\n      const indexesForName = Asserts.assertValue(\n        meshNameToParticleIndexes.get(name)\n      );\n      const nextIndexForName = Asserts.assertValue(nextIndexMap.get(name));\n      const nextIndex = indexesForName[nextIndexForName];\n      mod.updateParticleByIndex(nextIndex, fn);\n      nextIndexMap.set(name, nextIndexForName + 1);\n    },\n    updateParticleByIndex: (index, fn) => {\n      const particle = system.particles[index];\n      Asserts.assertValue(particle, `particle not found for ${index}`);\n      particle.alive = true;\n      fn(particle, index);\n    },\n    updateParticlesByName: (name, fn) => {\n      const indexes = meshNameToParticleIndexes.get(name);\n      if (indexes) {\n        indexes.forEach((index) => {\n          mod.updateParticleByIndex(index, fn);\n        });\n      }\n    },\n    removeMesh: (mesh: BabMesh) => {\n      meshToCounts.delete(mesh);\n      meshToParticleIndexes.delete(mesh);\n      meshNameToParticleIndexes.delete(mesh.name);\n      meshNameToMesh.delete(mesh.name);\n      mod.rebuild();\n    },\n    addMesh: (mesh: BabMesh, n = 1) => {\n      if (meshToCounts.has(mesh)) {\n        throw new Error(\n          `Mesh ${mesh.name} already exists in the Sps. Use removeMesh to remove it first.`\n        );\n      }\n      nextIndexMap.set(mesh.name, 0);\n      meshToCounts.set(mesh, n);\n      meshNameToMesh.set(mesh.name, mesh);\n      mod.rebuild();\n      mod.clearParticles();\n      mesh.setEnabled(false);\n    },\n    rebuild: () => {\n      renewSps();\n      meshToParticleIndexes.clear();\n      try {\n        meshToCounts.forEach((count, mesh) => {\n          system.addShape(mesh, count);\n          for (let i = 0; i < count; i++) {\n            const index = system.particles.length - 1 - i;\n\n            meshToParticleIndexes.set(mesh, [\n              ...(meshToParticleIndexes.get(mesh) || []),\n              index,\n            ]);\n            meshNameToParticleIndexes.set(mesh.name, [\n              ...(meshToParticleIndexes.get(mesh) || []),\n              index,\n            ]);\n          }\n        });\n        const mesh = system.buildMesh();\n        if (material) {\n          mesh.material = Materials.getMaterial(scene, material);\n        }\n        onMeshBuild?.(mesh);\n      } catch (e) {\n        console.error(e);\n      }\n    },\n    syncParticlestoMeshes: () => {\n      meshToParticleIndexes.forEach((indexes, mesh) => {\n        for (let i = 0; i < indexes.length; i++) {\n          const index = indexes[i];\n          const particle = Asserts.assertValue(system.particles[index]);\n          particle.position.copyFrom(mesh.position);\n          particle.rotation.copyFrom(mesh.rotation);\n          particle.scaling.copyFrom(mesh.scaling);\n          if (mesh.material instanceof StandardMaterial) {\n            const c3 = mesh.material.diffuseColor;\n            particle.color = new Color4(c3.r, c3.g, c3.b, mesh.material.alpha);\n          }\n        }\n      });\n    },\n    dispose: () => {\n      meshToCounts.clear();\n      meshToParticleIndexes.clear();\n      meshNameToParticleIndexes.clear();\n      meshNameToMesh.clear();\n      nextIndexMap.clear();\n      system?.mesh?.dispose();\n      system.dispose();\n    },\n    update: () => {\n      system.setParticles();\n      nextIndexMap.forEach((_, meshName) => {\n        nextIndexMap.set(meshName, 0);\n      });\n      system.particles.forEach((particle) => {\n        particle.alive = false;\n        particle.color = TRANSPARENT_COLOR;\n      });\n    },\n  };\n  return mod;\n};\n\nconst TRANSPARENT_COLOR = new Color4(0, 0, 0, 0);\n","import { getParticleSystem } from \"./getParticleSystem\";\nimport { getSolidParticleSystem } from \"./getSolidParticleSystem\";\nimport { Sps } from \"./Sps\";\nexport type { Sps } from \"./Sps\";\nexport const Particles = {\n  getSolidParticleSystem,\n  getParticleSystem,\n  Sps,\n};\n","import { Ray } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { v3 } from \"../bab/v3\";\n\nexport const createRay = (\n  origin: Point3,\n  direction: Point3,\n  length?: number\n) => {\n  return new Ray(v3(origin), v3(direction), length);\n};\n","import type { Ray, TrianglePickingPredicate } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickWithRay = (\n  scene: Scene,\n  ray: Ray,\n  options: Partial<{\n    predicate: (mesh: AbstractMesh) => boolean;\n    fastCheck: boolean;\n    trianglePredicate: TrianglePickingPredicate;\n  }> = {}\n) => {\n  const {\n    trianglePredicate,\n    fastCheck,\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n  } = options;\n  return scene.pickWithRay(ray, predicate, fastCheck, trianglePredicate);\n};\n","import { createRay } from \"./createRay\";\nimport { pickWithRay } from \"./pickWithRay\";\n\nexport const Rays = {\n  createRay,\n  pickWithRay,\n};\n","import { Scene } from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const createScene = (engine: BabEngine) => {\n  return new Scene(engine);\n};\n","import type { Scene } from \"@babylonjs/core\";\n\n// babylon magic BS\nimport \"@babylonjs/core\";\nimport \"@babylonjs/inspector\";\n\nexport const toggleInspector = (scene: Scene) => {\n  if (scene.debugLayer.isVisible()) {\n    scene.debugLayer.hide();\n  } else {\n    scene.debugLayer.show();\n  }\n};\n","import { createScene } from \"./createScene\";\nimport { renderOnce } from \"./renderOnce\";\nimport { toggleInspector } from \"./toggleInspector\";\n\nexport const Scenes = {\n  createScene,\n  toggleInspector,\n  renderOnce,\n};\n","import type { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\n\nexport const removeShadowFromMesh = (mesh: Mesh | AbstractMesh) => {\n  const scene = mesh.getScene();\n  mesh.dispose();\n  const shadowCasters = scene.getLightsByTags(\"shadowCaster\");\n  shadowCasters.forEach((caster) => {\n    const shadowGenerator = caster.metadata[\n      \"shadowGenerator\"\n    ] as ShadowGenerator;\n    shadowGenerator.removeShadowCaster(mesh);\n  });\n};\n","import type { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\nimport type { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { removeShadowFromMesh } from \"../mesh/removeShadowFromMesh\";\n\nexport const addShadowToMesh = (mesh: Mesh | InstancedMesh) => {\n  const scene = mesh.getScene();\n  const shadowCasters = scene.getLightsByTags(\"shadowCaster\");\n  shadowCasters.forEach((caster) => {\n    const shadowGenerator = caster.metadata[\n      \"shadowGenerator\"\n    ] as ShadowGenerator;\n    shadowGenerator.addShadowCaster(mesh);\n  });\n  return () => {\n    removeShadowFromMesh(mesh);\n  };\n};\n","import { addShadowToMesh } from \"./addShadowToMesh\";\n\nexport const Shadows = {\n  addShadowToMesh,\n};\n","import { Constants } from \"@babylonjs/core\";\nimport { GlowLayer, type IGlowLayerOptions } from \"@babylonjs/core\";\nimport { Color4 } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const addGlowLayer = (\n  scene: Scene,\n  name: string,\n  options: Partial<IGlowLayerOptions> = {}\n) => {\n  const gl = new GlowLayer(name, scene, options);\n  gl.neutralColor = new Color4(0, 0, 0, 0);\n  return gl;\n};\n\nexport const Specials = {\n  addGlowLayer,\n  Constants,\n};\n","interface Frame {\n  frame: { x: number; y: number; w: number; h: number };\n}\n\ninterface AtlasJSON {\n  frames: Record<string, Frame>;\n}\n\ninterface BabylonSpriteMapFrame {\n  filename: string;\n  frame: { x: number; y: number; w: number; h: number };\n  rotated: boolean;\n  trimmed: boolean;\n  spriteSourceSize: { x: number; y: number; w: number; h: number };\n  sourceSize: { w: number; h: number };\n}\n\ninterface BabylonSpriteMapJSON {\n  frames: BabylonSpriteMapFrame[];\n}\n\nexport async function createTextureAtlas({\n  baseUrl,\n  imageNames,\n  atlasSize,\n  padding = 0,\n}: {\n  atlasSize: number;\n  baseUrl: string;\n  imageNames: string[];\n  padding?: number;\n}): Promise<{\n  canvas: HTMLCanvasElement;\n  atlasBlob: Blob;\n  spritePackageManagerJson: AtlasJSON;\n  babylonSpriteMapJson: BabylonSpriteMapJSON;\n}> {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = atlasSize;\n  canvas.height = atlasSize;\n  const ctx = canvas.getContext(\"2d\")!;\n\n  const simpleFrames: Record<string, Frame> = {};\n  const babylonFrames: BabylonSpriteMapFrame[] = [];\n\n  let x = 0;\n  let y = 0;\n  let rowHeight = 0;\n\n  for (const name of imageNames) {\n    const filename = name.endsWith(\".png\") ? name : `${name}.png`;\n    const img = await loadImage(`${baseUrl}/${filename}`);\n\n    const spriteWidth = img.width + padding * 2;\n    const spriteHeight = img.height + padding * 2;\n\n    if (x + spriteWidth > atlasSize) {\n      x = 0;\n      y += rowHeight;\n      rowHeight = 0;\n    }\n\n    if (y + spriteHeight > atlasSize) {\n      throw new Error(`Not enough space in atlas for image: ${filename}`);\n    }\n\n    ctx.drawImage(img, x + padding, y + padding);\n\n    simpleFrames[filename] = {\n      frame: {\n        x: x + padding,\n        y: y + padding,\n        w: img.width,\n        h: img.height,\n      },\n    };\n\n    babylonFrames.push({\n      filename,\n      frame: {\n        x: x + padding,\n        y: y + padding,\n        w: img.width,\n        h: img.height,\n      },\n      rotated: false,\n      trimmed: false,\n      spriteSourceSize: { x: 0, y: 0, w: img.width, h: img.height },\n      sourceSize: { w: img.width, h: img.height },\n    });\n\n    x += spriteWidth;\n    rowHeight = Math.max(rowHeight, spriteHeight);\n  }\n\n  const atlasBlob = await new Promise<Blob>((resolve) =>\n    canvas.toBlob((blob) => resolve(blob!), \"image/png\")\n  );\n\n  return {\n    canvas,\n    atlasBlob,\n    spritePackageManagerJson: { frames: simpleFrames },\n    babylonSpriteMapJson: { frames: babylonFrames },\n  };\n}\n\nasync function loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.src = src;\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(new Error(`Failed to load image: ${src}`));\n  });\n}\n","import {\n  type Scene,\n  SpriteManager,\n  SpriteManagerOptions,\n  SpriteMap,\n  SpritePackedManager,\n} from \"@babylonjs/core\";\nimport { isDefined, isUndefined } from \"@mjt-engine/object\";\nimport { BabSpriteManager } from \"../type/BabSpriteManager\";\n\nexport const getSpritePackedManager = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    capacity: number;\n    cellSize: { width: number; height: number } | number;\n    atlasUrl: string;\n    atlasBlob?: Blob;\n    epsilon?: number;\n    samplingMode?: number;\n    fromPacked?: boolean;\n    spriteJSON?: any | null;\n    options?: SpriteManagerOptions;\n  }> = {}\n): BabSpriteManager => {\n  const managerMaybe = scene?.spriteManagers?.find((sm) => sm.name === name);\n  if (isDefined(managerMaybe)) {\n    return managerMaybe as BabSpriteManager;\n  }\n  const {\n    capacity = 1,\n    atlasUrl,\n    atlasBlob,\n    epsilon,\n    samplingMode,\n    spriteJSON,\n    options: spriteManagerOptions,\n  } = options;\n  let objectUrl: string | undefined;\n  try {\n    if (atlasBlob) {\n      objectUrl = URL.createObjectURL(atlasBlob);\n    }\n    const realizedUrl = isDefined(atlasUrl) ? atlasUrl : objectUrl;\n    if (isUndefined(realizedUrl)) {\n      throw new Error(\"altasUrl or atlasBlob is required\", { cause: options });\n    }\n    return new SpritePackedManager(\n      name,\n      realizedUrl,\n      capacity,\n      scene,\n      spriteJSON,\n      epsilon,\n      samplingMode,\n      spriteManagerOptions\n    );\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n};\n\nexport const getSpriteManager = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    capacity: number;\n    cellSize: { width: number; height: number } | number;\n    atlasUrl: string;\n    atlasBlob?: Blob;\n    epsilon?: number;\n    samplingMode?: number;\n    fromPacked?: boolean;\n    spriteJSON?: any | null;\n    options?: SpriteManagerOptions;\n  }> = {}\n): BabSpriteManager => {\n  const managerMaybe = scene?.spriteManagers?.find((sm) => sm.name === name);\n  if (isDefined(managerMaybe)) {\n    return managerMaybe as BabSpriteManager;\n  }\n  const {\n    capacity = 1,\n    cellSize = 64,\n    atlasUrl,\n    atlasBlob,\n    epsilon,\n    samplingMode,\n    fromPacked,\n    spriteJSON,\n    options: spriteManagerOptions,\n  } = options;\n  let objectUrl: string | undefined;\n  try {\n    if (atlasBlob) {\n      objectUrl = URL.createObjectURL(atlasBlob);\n    }\n    const realizedUrl = isDefined(atlasUrl) ? atlasUrl : objectUrl;\n    if (isUndefined(realizedUrl)) {\n      throw new Error(\"altasUrl or atlasBlob is required\", { cause: options });\n    }\n    return new SpriteManager(\n      name,\n      realizedUrl,\n      capacity,\n      cellSize,\n      scene,\n      epsilon,\n      samplingMode,\n      fromPacked,\n      spriteJSON,\n      spriteManagerOptions\n    );\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n};\n","import { type Scene, Sprite } from \"@babylonjs/core\";\nimport { assertValue } from \"@mjt-engine/assert\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { getSpriteManager } from \"./getSpriteManager\";\n\nexport const getSprite = (\n  scene: Scene,\n  name: string,\n  spriteManagerName: string\n): Sprite => {\n  const spriteManager = assertValue(getSpriteManager(scene, spriteManagerName));\n  const spriteMaybe = spriteManager?.sprites?.find((s) => s.name === name);\n  if (isDefined(spriteMaybe)) {\n    return spriteMaybe;\n  }\n  return new Sprite(name, spriteManager);\n};\n","import { createTextureAtlas } from \"./createTextureAtlas\";\nimport { getSprite } from \"./getSprite\";\nimport { getSpriteManager, getSpritePackedManager } from \"./getSpriteManager\";\n\nexport const Sprites = {\n  getSpriteManager,\n  getSprite,\n  createTextureAtlas,\n  getSpritePackedManager,\n};\n","import { Curve3 } from \"@babylonjs/core\";\nimport type { Vector3 } from \"@babylonjs/core\";\nimport type { SolidParticle } from \"@babylonjs/core\";\nimport { Maths, toVec3 } from \"@mjt-engine/math\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { Randoms, type NextRandom } from \"@mjt-engine/random\";\nimport { v3 } from \"../bab/v3\";\n\nexport const animateExplosion = (\n  particle: SolidParticle,\n\n  options: Partial<{\n    random: NextRandom;\n    radius: number;\n    maxBounce: number;\n    groundZ: number;\n    speed: number;\n    decay: number;\n    dispose: () => void;\n  }> = {}\n) => {\n  const {\n    random = Randoms.globalRandom,\n    radius = 1,\n    maxBounce = 0,\n    groundZ = 0,\n    speed = 20,\n    decay = 0.01,\n    dispose = () => (particle.isVisible = false),\n  } = options;\n\n  // const random = Noises.noiseStream(seed);\n  // use path\n  {\n    const path = particle.props?.[\"path\"] as Vector3[];\n    if (isDefined(path) && path.length > 0) {\n      const next = path.pop();\n      if (!next) {\n        throw new Error(\"No next value from path\", { cause: path });\n      }\n      // console.log(`next: ${next.x} ${next.y} ${next.z}`);\n      particle.position = next;\n      return;\n    }\n  }\n\n  // setup path\n  {\n    const { bounces = maxBounce } = particle.props ?? {};\n    if (bounces <= 0) {\n      if (random() < decay) {\n        dispose();\n      }\n      return;\n    }\n    const bounceEnergy = bounces / maxBounce;\n    const start = particle.position;\n    const [x, y, z] = toVec3(start);\n\n    const rg = (x: number) => {\n      return (random() * radius * 2 - radius) * (bounceEnergy / 4) + x;\n    };\n\n    // ground position\n    const [gx, gy] = [rg(x), rg(y)];\n\n    const end = v3([gx, gy, groundZ]);\n\n    const [mx, my, mz] = toVec3(Maths.midPoint3(start, end));\n    const mid1 = v3(mx, my, z - random() * bounceEnergy * 3);\n    // const mid2 = v3(x, y, mz - random() * bounceEnergy * 3);\n\n    const catRom = Curve3.CreateCatmullRomSpline([start, mid1, end], speed);\n    const path = catRom.getPoints().reverse();\n\n    // const rotationAxis = v3([0, 1, 0]);\n    // const rotationAmount = 2 * random() - 1;\n    // mesh.rotate(v3(rotationAxis), rotationAmount);\n    // console.log(`mb ${maxBounce}, bounces: ${bounces} ${Date.now()}`);\n    const pathMetadata = {\n      path,\n      bounces: bounces - 1,\n      // rotationAxis: [2 * random() - 1, 2 * random() - 1, 2 * random() - 1],\n    };\n    const metadata = particle.props ?? {};\n    particle.props = { ...metadata, ...pathMetadata };\n  }\n};\n","/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nexport class AndOrNotEvaluator {\n    /**\n     * Evaluate a query\n     * @param query defines the query to evaluate\n     * @param evaluateCallback defines the callback used to filter result\n     * @returns true if the query matches\n     */\n    static Eval(query, evaluateCallback) {\n        if (!query.match(/\\([^()]*\\)/g)) {\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n        }\n        else {\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\n                // remove parenthesis\n                r = r.slice(1, r.length - 1);\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n            });\n        }\n        if (query === \"true\") {\n            return true;\n        }\n        if (query === \"false\") {\n            return false;\n        }\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\n    }\n    static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {\n        evaluateCallback =\n            evaluateCallback ||\n                ((r) => {\n                    return r === \"true\" ? true : false;\n                });\n        let result;\n        const or = parenthesisContent.split(\"||\");\n        for (const i in or) {\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n                const and = ori.split(\"&&\");\n                if (and.length > 1) {\n                    for (let j = 0; j < and.length; ++j) {\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n                        if (andj !== \"true\" && andj !== \"false\") {\n                            if (andj[0] === \"!\") {\n                                result = !evaluateCallback(andj.substring(1));\n                            }\n                            else {\n                                result = evaluateCallback(andj);\n                            }\n                        }\n                        else {\n                            result = andj === \"true\" ? true : false;\n                        }\n                        if (!result) {\n                            // no need to continue since 'false && ... && ...' will always return false\n                            ori = \"false\";\n                            break;\n                        }\n                    }\n                }\n                if (result || ori === \"true\") {\n                    // no need to continue since 'true || ... || ...' will always return true\n                    result = true;\n                    break;\n                }\n                // result equals false (or undefined)\n                if (ori !== \"true\" && ori !== \"false\") {\n                    if (ori[0] === \"!\") {\n                        result = !evaluateCallback(ori.substring(1));\n                    }\n                    else {\n                        result = evaluateCallback(ori);\n                    }\n                }\n                else {\n                    result = ori === \"true\" ? true : false;\n                }\n            }\n        }\n        // the whole parenthesis scope is replaced by 'true' or 'false'\n        return result ? \"true\" : \"false\";\n    }\n    static _SimplifyNegation(booleanString) {\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\n            // remove whitespaces\n            r = r.replace(/[\\s]/g, () => \"\");\n            return r.length % 2 ? \"!\" : \"\";\n        });\n        booleanString = booleanString.trim();\n        if (booleanString === \"!true\") {\n            booleanString = \"false\";\n        }\n        else if (booleanString === \"!false\") {\n            booleanString = \"true\";\n        }\n        return booleanString;\n    }\n}\n//# sourceMappingURL=andOrNotEvaluator.js.map","import { AndOrNotEvaluator } from \"./andOrNotEvaluator.js\";\n/**\n * Class used to store custom tags\n */\nexport class Tags {\n    /**\n     * Adds support for tags on the given object\n     * @param obj defines the object to use\n     */\n    static EnableFor(obj) {\n        obj._tags = obj._tags || {};\n        obj.hasTags = () => {\n            return Tags.HasTags(obj);\n        };\n        obj.addTags = (tagsString) => {\n            return Tags.AddTagsTo(obj, tagsString);\n        };\n        obj.removeTags = (tagsString) => {\n            return Tags.RemoveTagsFrom(obj, tagsString);\n        };\n        obj.matchesTagsQuery = (tagsQuery) => {\n            return Tags.MatchesQuery(obj, tagsQuery);\n        };\n    }\n    /**\n     * Removes tags support\n     * @param obj defines the object to use\n     */\n    static DisableFor(obj) {\n        delete obj._tags;\n        delete obj.hasTags;\n        delete obj.addTags;\n        delete obj.removeTags;\n        delete obj.matchesTagsQuery;\n    }\n    /**\n     * Gets a boolean indicating if the given object has tags\n     * @param obj defines the object to use\n     * @returns a boolean\n     */\n    static HasTags(obj) {\n        if (!obj._tags) {\n            return false;\n        }\n        const tags = obj._tags;\n        for (const i in tags) {\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Gets the tags available on a given object\n     * @param obj defines the object to use\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\n     * @returns the tags\n     */\n    static GetTags(obj, asString = true) {\n        if (!obj._tags) {\n            return null;\n        }\n        if (asString) {\n            const tagsArray = [];\n            for (const tag in obj._tags) {\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\n                    tagsArray.push(tag);\n                }\n            }\n            return tagsArray.join(\" \");\n        }\n        else {\n            return obj._tags;\n        }\n    }\n    /**\n     * Adds tags to an object\n     * @param obj defines the object to use\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\n     */\n    static AddTagsTo(obj, tagsString) {\n        if (!tagsString) {\n            return;\n        }\n        if (typeof tagsString !== \"string\") {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        for (const tag of tags) {\n            Tags._AddTagTo(obj, tag);\n        }\n    }\n    /**\n     * @internal\n     */\n    static _AddTagTo(obj, tag) {\n        tag = tag.trim();\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\n            return;\n        }\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\n            return;\n        }\n        Tags.EnableFor(obj);\n        obj._tags[tag] = true;\n    }\n    /**\n     * Removes specific tags from a specific object\n     * @param obj defines the object to use\n     * @param tagsString defines the tags to remove\n     */\n    static RemoveTagsFrom(obj, tagsString) {\n        if (!Tags.HasTags(obj)) {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        for (const t in tags) {\n            Tags._RemoveTagFrom(obj, tags[t]);\n        }\n    }\n    /**\n     * @internal\n     */\n    static _RemoveTagFrom(obj, tag) {\n        delete obj._tags[tag];\n    }\n    /**\n     * Defines if tags hosted on an object match a given query\n     * @param obj defines the object to use\n     * @param tagsQuery defines the tag query\n     * @returns a boolean\n     */\n    static MatchesQuery(obj, tagsQuery) {\n        if (tagsQuery === undefined) {\n            return true;\n        }\n        if (tagsQuery === \"\") {\n            return Tags.HasTags(obj);\n        }\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\n    }\n}\n//# sourceMappingURL=tags.js.map","import { Mesh } from \"@babylonjs/core\";\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { v3 } from \"../bab/v3\";\nimport { getBoxInstance } from \"../mesh/getBoxInstance\";\n\nexport const voxDataToComplexModel = (\n  scene: Scene,\n  voxData: VoxData,\n  name: string\n) => {\n  const { XYZI, RGBA } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n  const parent = new Mesh(name, scene);\n  // const centeringNode = new Mesh(`centering-${name}`);\n  const meshes = XYZI.map((xyzi, index) => {\n    const color = colors[xyzi.i];\n    const mesh = getBoxInstance(scene, `voxel-${color}`, {\n      color,\n      material: `voxel-material-${color}`,\n    });\n    mesh.position = v3(xyzi);\n    // mesh.parent = centeringNode;\n    mesh.parent = parent;\n\n    return mesh;\n  });\n  Tags.AddTagsTo(parent, \"complex\");\n  return parent;\n};\n","\nexport const toOrderedString = (obj: object) => {\n  const sorted = Object.entries(obj).sort((a, b) => {\n    const [keyA] = a;\n    const [keyB] = b;\n    return keyA.localeCompare(keyB);\n  });\n  return JSON.stringify(sorted);\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\n\nexport const groupMeshesByMaterial = (meshes: Mesh[]) => {\n  const result: Record<string, Mesh[]> = {};\n\n  meshes.forEach((mesh) => {\n    const materialName = mesh?.material?.name;\n    if (!materialName) {\n      throw new Error(\"Mesh material is missing name\", { cause: mesh });\n    }\n    const meshes = result[materialName] ?? [];\n    meshes.push(mesh);\n    result[materialName] = meshes;\n  });\n  return result;\n};\n","import { Mesh } from \"@babylonjs/core\";\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { toVec3 } from \"@mjt-engine/math\";\nimport { Arrays, isDefined } from \"@mjt-engine/object\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport { getBox } from \"../mesh/getBox\";\nimport { mergeMeshes } from \"../mesh/mergeMeshes\";\nimport { toOrderedString } from \"../util/toOrderedString\";\nimport { groupMeshesByMaterial } from \"./groupMeshesByMaterial\";\n\nexport const voxDataToMergedModel = (\n  scene: Scene,\n  voxData: VoxData,\n  name: string\n) => {\n  const { XYZI, RGBA } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n  // console.log(`${name} voxels: ${XYZI.length} colors: ${colors.length}`);\n  // const parent = new Mesh(name, scene);\n  // const centeringNode = new Mesh(`centering-${name}`);\n  const voxels = XYZI.map((xyzi, index) => {\n    const color = colors[xyzi.i];\n\n    const [x, y, z] = toVec3(xyzi);\n    const mesh = getBox(\n      scene,\n      `voxel-merged-${color}-${toOrderedString(xyzi)}`,\n      {\n        position: [x, y, z],\n        // color,\n        // material: `voxel-merged-material-${color}`,\n        material: \"voxel-material\",\n        colors: Arrays.from(6).map(() => color),\n      }\n    );\n    mesh.setEnabled(false);\n    return mesh;\n  });\n  const grouped = groupMeshesByMaterial(voxels);\n  const subMerged = Object.values(grouped).map((group) => mergeMeshes(group));\n\n  const merged = new Mesh(`merged-${name}`, scene);\n  subMerged.filter(isDefined).forEach((m) => (m.parent = merged));\n\n  const material = getMaterial(scene, \"voxel-material\", \"standard\");\n\n  subMerged.filter(isDefined).forEach((m) => (m.material = material));\n\n  // voxels.forEach((v) => v.setParent(merged));\n  merged.metadata = {\n    voxels: voxels,\n  };\n\n  // const merged = mergeMeshes(meshes, {\n  //   // multiMultiMaterials: true,\n  //   disposeSource: true,\n  // });\n  // merged.name = name;\n  // merged.refreshBoundingInfo();\n  // const center = merged.getBoundingInfo().boundingBox.center;\n  // merged.dispose();\n  // centeringNode.position = centeringNode.position.subtract(center);\n  // centeringNode.parent = parent;\n  // return parent;\n  Tags.AddTagsTo(merged, \"merged\");\n  // const model = new TransformNode(name);\n  const model = new Mesh(name, scene);\n  model.metadata = {\n    voxels: voxels,\n  };\n  merged.parent = model;\n\n  // merged.refreshBoundingInfo();\n  // const mergedCenter = merged.getBoundingInfo().boundingSphere.center;\n  // merged.position = v3(0,0,-30);\n  return model;\n};\n","import { animateExplosion } from \"./animateExplosion\";\nimport { voxDataToComplexModel } from \"./voxDataToComplexModel\";\nimport { voxDataToMergedModel } from \"./voxDataToMergedModel\";\nimport { voxDataToSps } from \"./voxDataToSps\";\n\nexport const Voxels = {\n  animateExplosion,\n  voxDataToSps,\n  voxDataToMergedModel,\n  voxDataToComplexModel,\n};\n","import * as BABYLON from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const spsDebug = ({\n  engine,\n  canvas,\n}: {\n  engine: BabEngine;\n  canvas: HTMLCanvasElement;\n}) => {\n  const scene = new BABYLON.Scene(engine);\n  console.log(scene);\n\n  const camera = new BABYLON.ArcRotateCamera(\n    \"ArcRotateCamera\",\n    -Math.PI / 2,\n    Math.PI / 2.2,\n    50,\n    new BABYLON.Vector3(0, 0, 0),\n    scene\n  );\n  camera.attachControl(canvas, true);\n  const light = new BABYLON.HemisphericLight(\n    \"light\",\n    new BABYLON.Vector3(0, 1, -1),\n    scene\n  );\n  const mat1 = new BABYLON.StandardMaterial(\"mat\");\n  mat1.diffuseTexture = new BABYLON.Texture(\"textures/earth.jpg\");\n  const mat2 = new BABYLON.StandardMaterial(\"mat\");\n  const fire = new BABYLON.Texture(\"textures/fire.jpg\");\n  mat2.diffuseTexture = fire;\n  const SPS = new BABYLON.SolidParticleSystem(\"SPS\", scene, {\n    useModelMaterial: true,\n  });\n  const box1 = BABYLON.MeshBuilder.CreateBox(\"FOO\");\n  // const poly = BABYLON.MeshBuilder.CreatePolyhedron(\"p\", { type: 2 });\n  box1.material = mat1;\n  // scene.addMesh(poly)\n  SPS.addShape(box1, 10_000); // 20 spheres\n  // SPS.addShape(box2, 20); // 20 spheres\n  // SPS.addShape(poly, 120); // 120 polyhedrons\n  // SPS.addShape(sphere, 80); // 80 other spheres\n  // sphere.dispose(); //dispose of original model sphere\n  // poly.dispose(); //dispose of original model poly\n\n  const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh\n\n  // initiate particles function\n  SPS.initParticles = () => {\n    for (let p = 0; p < SPS.nbParticles; p++) {\n      const particle = SPS.particles[p];\n      particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n      particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n      particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n    }\n  };\n\n  //Update SPS mesh\n  SPS.initParticles();\n  SPS.setParticles();\n  const update = () => {\n    const a = Math.sin(Date.now() * 0.005);\n\n    // mat.alpha=a\n    // box1.rotation.x = a\n    // box.rotate(new BABYLON. Vector3(0,1,0), new BABYLON.Vector3(0.1,0.1, 0.1), BABYLON.Space.WORLD);\n    // box.useVertexColors\n    // console.log(\"render\");\n    SPS.particles.forEach((p, i) => {\n      // console.log(p.name)\n      if (i > 20) {\n        p.rotation.x = a;\n        mat1.alpha = a;\n        mat1.diffuseTexture = fire;\n      } else {\n        p.rotation.y = a;\n      }\n    });\n    SPS.setParticles();\n  };\n\n  // mesh.material = mat;\n  // scene.registerBeforeRender(() => {});\n\n  return { scene, update };\n};\n\n\n","import * as BABYLON from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\nimport { Cameras } from \"../camera/Cameras\";\nimport { Lights } from \"../light/Lights\";\nimport { Textures } from \"../texture/Textures\";\nimport { Meshes } from \"../mesh/Meshes\";\nimport { Particles } from \"../particle/Particles\";\nimport { Materials } from \"../material/Materials\";\nimport { Noises } from \"@mjt-engine/noise\";\nimport { Colors } from \"@mjt-engine/color\";\n\nexport const spsDebug2 = ({\n  engine,\n  canvas,\n}: {\n  engine: BabEngine;\n  canvas: HTMLCanvasElement;\n}) => {\n  const scene = new BABYLON.Scene(engine);\n  console.log(scene);\n\n  const camera = Cameras.getArcRotateCamera(scene, \"ArcRotateCamera\", {\n    alpha: -Math.PI / 2,\n    beta: Math.PI / 2.2,\n    radius: 50,\n    target: [0, 0, 0],\n  });\n  camera.attachControl(canvas, true);\n  const light = Lights.getHemisphericLight(scene, \"light\", {\n    direction: [0, 1, -1],\n  });\n  const tex = Textures.getPathTexture(scene, \"tex\", {\n    src: \"/images/test.jpg\",\n  });\n  const mat = Materials.getMaterial(scene, \"mat\", {\n    opacityTexture: tex.name,\n    // diffuseColor: Colors.from(\"red\").alpha(0.99).toString(),\n\n    // alpha: 0.99,\n  });\n  // mat.needAlphaBlending = () => true;\n  // mat.alphaMode = BABYLON.Constants.ALPHA_COMBINE;\n  // mat.\n  // const box1 = BABYLON.MeshBuilder.CreateBox(\"box1\", {\n  //   ma: mat.name,\n  // });\n  // const SPS = new BABYLON.SolidParticleSystem(\"SPS\", scene);\n  const box1 = Meshes.getBox(\n    scene,\n    \"box1\"\n    //  { material: mat.name }\n  );\n  // const poly = BABYLON.MeshBuilder.CreatePolyhedron(\"p\", { type: 2 });\n  // box1.material = mat1;\n  // scene.addMesh(poly)\n\n  const sps = Particles.Sps(scene, \"sps\", {\n    material: mat.name,\n    updatable: true,\n    // enableDepthSort: true,\n\n    onMeshBuild: (mesh) => {\n      mesh.useVertexColors = true;\n      mesh.hasVertexAlpha = true;\n      // mesh.material = mat;\n    },\n  });\n  sps.addMesh(box1, 10_000); // 20 spheres\n  sps.updateParticlesByName(\"box1\", (particle, i) => {\n    particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n    particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n    particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n  });\n\n  // SPS.addShape(box1, 10000); // 20 spheres\n\n  // const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh\n\n  // // initiate particles function\n  // SPS.initParticles = () => {\n  //   for (let p = 0; p < SPS.nbParticles; p++) {\n  //     const particle = SPS.particles[p];\n  //     particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n  //     particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n  //     particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n  //   }\n  // };\n\n  // //Update SPS mesh\n  // SPS.initParticles();\n  // SPS.setParticles();\n  // sps.getInstance().mesh.useVertexColors = true;\n  const update = () => {\n    const s = Math.sin(Date.now() * 0.005);\n\n    const n = Noises.noiseStream(0);\n    // const n = () => 0.5;\n    sps.updateParticlesByName(\"box1\", (p, i) => {\n      p.color = new BABYLON.Color4(n(), n(), n(), 0.5);\n      if (Math.random() > 0.5) {\n        p.rotation.x = n() * s;\n      } else {\n        p.rotation.y = n() * s;\n      }\n    });\n    sps.update();\n\n    // SPS.particles.forEach((p, i) => {\n    //   // console.log(p.name)\n    //   if (i > 20) {\n    //     p.rotation.x = a;\n    //     // mat1.alpha = a;\n    //     // mat1.diffuseTexture = fire;\n    //   } else {\n    //     p.rotation.y = a;\n    //   }\n    // });\n    // SPS.setParticles();\n  };\n\n  return { scene, update };\n};\n","import { spsDebug } from \"./spsDebug\";\nimport { spsDebug2 } from \"./spsDebug2\";\n\nexport const Debugs = {\n  spsDebug,\n  spsDebug2,\n};\n"],"names":["v3","xOrPosition","y","z","Vector3","xx","yy","zz","toVec3","updateArcRotateCameraPosition","camera","position","currentAlpha","currentBeta","currentRadius","attachArcRotateCameraControls","options","keySensitivity","mouseSensitivity","parent","action","defaultAlpha","defaultBeta","defaultRadius","update","x","keyAnim","Inputs","MOUSE_STATE","event","auxDownLast","diff","Maths","toVec2","mouseAnim","delta","createCanvas","width","height","canvas","createWebGlEngine","optionsOrCanvas","antialias","engine","Engine","helloVrWorld","scene","BABYLON","sphere","material","light","environment","shadowGenerator","vrHelper","plane","advancedTexture","GUI","panel","header","picker","value","c3","color","hex","Colors","Color3","c4","c","result","Color4","pickMesh","predicate","ray","Matrix","walkMeshes","mesh","walker","Scene","m","attachUniversalCameraControls","e","isDefined","isUndefined","createTopDownCamera","name","unitsTall","unitsWide","cameraLevel","disposeActive","UniversalCamera","Camera","getCamera","producer","updateCamera","alpha","beta","radius","target","rotation","minZ","maxZ","mode","orthoTop","orthoBottom","orthoLeft","orthoRight","iff","CAMERA_MODES","TargetCamera","ArcRotateCamera","getArcRotateCamera","getUniversalCamera","createDebugCamera","Cameras","getLight","updateLight","intensity","direction","HemisphericLight","PointLight","getHemisphericLight","getPointLight","Lights","getMesh","updatable","meshMaybe","updateStandardMaterial","diffuseTexture","emissiveTexture","ambientTexture","opacityTexture","diffuseColor","specularColor","ambientColor","emissiveColor","texture","colorAlpha","updateMaterial","StandardMaterial","getMaterial","type","PBRMaterial","updateMesh","receiveShadows","Mesh","p","getBox","depth","colors","MeshBuilder","getBoxInstance","rootName","rootMesh","getSphere","calcTopOfMeshWorldPosition","BabPolyMap","getPolyhedron","size","calcClientRectForMesh","meshVectors","worldMatrix","transformMatrix","viewport","coordinates","v","proj","minX","maxX","extent","minY","maxY","destroyMesh","recurse","disposeMaterials","disposeTextures","findClosestPick","picks","a","b","getCylinder","arc","tag","getLine","instance","buildLineMesh","points","useVertexAlpha","pointColors","_","index","fleshedPoints","getMeshAsync","getMeshInstance","Asserts","getMeshInstanceAsync","getPlane","doubleSided","billboard","getTorusKnot","voxDataToCorrectedPoints","voxData","XYZI","SIZE","scale","xVoxelCenterCorrection","yVoxelCenterCorrection","zVoxelCenterCorrection","xyzi","tuple2","tuple3","voxDataToSps","RGBA","rgba","r","g","sps","SolidParticleSystem","box","pc","point","colorIndex","particle","getVoxModel","src","metadata","voxes","isInstancedMesh","InstancedMesh","lookAt","from","to","mergeMeshes","meshes","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","pickMeshes","describeMesh","search","padding","entry","key","Texture","Meshes","helloWorld","STATE","ev","Babs","createWebGpuEngine","rest","WebGPUEngine","isWebGpuCapable","Engines","stopwatch","label","checkpoint","timeP","expr","renderOnce","sw","resolve","reject","reason","fixEyelashes","HIDE","GLOSS","fixEyes","textures","h","fixBumpMaps","fixDazFigure","loadDazFigure","props","path","SceneLoader","loadedScene","anim","progress","message","Models","copyToCanvas","image","copy","imageSrcToUrl","cvs","Images","imageToTexture","DynamicTexture","url","layerToPlane","layer","id","Randoms","imageLayersToScene","layers","builder","drawOnTexture","render","ctx","clearTexture","debugImage","Textures","labelElement","onclick","destroyTexture","tex","drawBackgroundOnTexture","drawTextOnTexture","text","backgroundColor","outline","fontFamily","fontStyle","outlineColor","textureSize","fontSize","font","measure","textX","top","textY","bbox","TEXTURE_SAMPLING_MODES","getTexture","updateTexture","hasAlpha","getDynamicTexture","generateMipMaps","samplingMode","init","samplingModeNumber","getHtmlElementTexture","element","HtmlElementTexture","getPathTexture","getGlowLayer","layerMaybe","GlowLayer","getHighlightLayer","HighlightLayer","Layers","Materials","getTransformNode","node","TransformNode","Nodes","getSolidParticleSystemsMetadata","spsMetadata","getParticleSystem","spsMaybe","getSolidParticleSystem","Sps","nextIndexMap","meshToCounts","meshToParticleIndexes","meshNameToParticleIndexes","meshNameToMesh","onMeshBuild","system","renewSps","mod","i","TRANSPARENT_COLOR","meshName","fn","indexesForName","nextIndexForName","nextIndex","indexes","n","count","Particles","createRay","origin","length","Ray","pickWithRay","trianglePredicate","fastCheck","Rays","createScene","toggleInspector","Scenes","removeShadowFromMesh","caster","addShadowToMesh","Shadows","addGlowLayer","gl","Specials","Constants","createTextureAtlas","baseUrl","imageNames","atlasSize","simpleFrames","babylonFrames","rowHeight","filename","img","loadImage","spriteWidth","spriteHeight","atlasBlob","blob","getSpritePackedManager","managerMaybe","sm","capacity","atlasUrl","epsilon","spriteJSON","spriteManagerOptions","objectUrl","realizedUrl","SpritePackedManager","getSpriteManager","cellSize","fromPacked","SpriteManager","getSprite","spriteManagerName","spriteManager","assertValue","spriteMaybe","s","Sprite","Sprites","animateExplosion","random","maxBounce","groundZ","speed","decay","dispose","next","bounces","bounceEnergy","start","rg","gx","gy","end","mx","my","mz","mid1","pathMetadata","Curve3","AndOrNotEvaluator","query","evaluateCallback","parenthesisContent","or","ori","and","j","andj","booleanString","Tags","obj","tagsString","tagsQuery","tags","asString","tagsArray","t","voxDataToComplexModel","toOrderedString","sorted","keyA","keyB","groupMeshesByMaterial","materialName","voxDataToMergedModel","voxels","Arrays","grouped","subMerged","group","merged","model","Voxels","spsDebug","mat1","mat2","fire","SPS","box1","spsDebug2","mat","Noises","Debugs"],"mappings":"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","x_google_ignoreList":[112,113]}