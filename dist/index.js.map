{"version":3,"file":"index.js","sources":["../src/bab/v3.ts","../src/mesh/updateArcRotateCameraPosition.ts","../src/camera/attachArcRotateCameraControls.ts","../src/bab/createCanvas.ts","../src/engine/createWebglEngine.ts","../src/model/pickMesh.ts","../src/model/walkMeshes.ts","../src/camera/attachUniversalCameraControls.ts","../src/camera/createTopDownCamera.ts","../src/camera/getCamera.ts","../src/camera/updateCamera.ts","../src/camera/getArcRotateCamera.ts","../src/camera/getUniversalCamera.ts","../src/camera/createDebugCamera.ts","../src/camera/getFreeCamera.ts","../src/camera/getWebXrCamera.ts","../src/camera/Cameras.ts","../src/light/getLight.ts","../src/light/updateLight.ts","../src/light/getHemisphericLight.ts","../src/light/getPointLight.ts","../src/light/Lights.ts","../src/bab/c4.ts","../src/mesh/getMesh.ts","../src/bab/c3.ts","../src/material/updateStandardMaterial.ts","../src/material/updateMaterial.ts","../src/material/getMaterial.ts","../src/mesh/updateMesh.ts","../src/mesh/getBox.ts","../src/mesh/getBoxInstance.ts","../src/mesh/getSphere.ts","../src/mesh/pickMesh.ts","../src/mesh/calcTopOfMeshWorldPosition.ts","../src/mesh/walkMeshes.ts","../src/mesh/getPolyhedron.ts","../src/mesh/calcClientRectForMesh.ts","../src/mesh/destroyMesh.ts","../src/mesh/findClosestPick.ts","../src/mesh/getCylinder.ts","../src/mesh/getLine.ts","../src/mesh/getMeshAsync.ts","../src/mesh/getMeshInstance.ts","../src/mesh/getMeshInstanceAsync.ts","../src/mesh/getPlane.ts","../src/mesh/getTorusKnot.ts","../src/voxel/voxDataToCorrectedPoints.ts","../src/voxel/voxDataToSps.ts","../src/mesh/getVoxModel.ts","../src/mesh/isInstancedMesh.ts","../src/mesh/lookAt.ts","../src/mesh/mergeMeshes.ts","../src/mesh/pickMeshes.ts","../src/mesh/describeMesh.ts","../src/mesh/Meshes.ts","../src/scene/createScene.ts","../src/util/Timers.ts","../src/scene/renderOnce.ts","../src/scene/toggleInspector.ts","../src/scene/Scenes.ts","../src/wxr/createDefaultHelper.ts","../src/wxr/createWebXrExperience.ts","../src/wxr/hellowXrWorld.ts","../src/bab/helloWorld.ts","../src/bab/Babs.ts","../src/engine/createWebGpuEngine.ts","../src/engine/isWebGpuCapable.ts","../src/engine/Engines.ts","../src/model/fix/fixEyelashes.ts","../src/model/fix/fixEyes.ts","../src/model/fix/fixBumpMaps.ts","../src/model/fix/fixDazFigure.ts","../src/model/loadDazFigure.ts","../src/model/Models.ts","../src/texture/copyToCanvas.ts","../src/util/imageSrcToUrl.ts","../src/texture/imageToTexture.ts","../src/texture/layerToPlane.ts","../src/texture/imageLayersToScene.ts","../src/texture/builder.ts","../src/texture/drawOnTexture.ts","../src/texture/clearTexture.ts","../src/texture/debugImage.ts","../src/texture/destroyTexture.ts","../src/texture/drawBackgroundOnTexture.ts","../src/texture/drawTextOnTexture.ts","../src/texture/TEXTURE_SAMPLING_MODES.ts","../src/texture/getTexture.ts","../src/texture/updateTexture.ts","../src/texture/getDynamicTexture.ts","../src/texture/samplingModeNumber.ts","../src/texture/getHtmlElementTexture.ts","../src/texture/getPathTexture.ts","../src/texture/Textures.ts","../src/layer/getGlowLayer.ts","../src/layer/getHighlightLayer.ts","../src/layer/Layers.ts","../src/material/Materials.ts","../src/node/getTransformNode.ts","../src/node/Nodes.ts","../src/particle/getParticleSystem.ts","../src/particle/getSolidParticleSystem.ts","../src/particle/Sps.ts","../src/particle/Particles.ts","../src/ray/createRay.ts","../src/ray/pickWithRay.ts","../src/ray/Rays.ts","../src/mesh/removeShadowFromMesh.ts","../src/shadow/addShadowToMesh.ts","../src/shadow/Shadows.ts","../src/special/Specials.ts","../src/sprite/createTextureAtlas.ts","../src/sprite/getSpriteManager.ts","../src/sprite/getSprite.ts","../src/sprite/Sprites.ts","../src/voxel/animateExplosion.ts","../node_modules/.pnpm/@babylonjs+core@8.6.1/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js","../node_modules/.pnpm/@babylonjs+core@8.6.1/node_modules/@babylonjs/core/Misc/tags.js","../src/voxel/voxDataToComplexModel.ts","../src/util/toOrderedString.ts","../src/voxel/groupMeshesByMaterial.ts","../src/voxel/voxDataToMergedModel.ts","../src/voxel/Voxels.ts","../src/wxr/createWebXrSessionManager.ts","../src/wxr/Wxrs.ts","../src/debug/spsDebug.ts","../src/debug/spsDebug2.ts","../src/debug/Debugs.ts"],"sourcesContent":["import { Vector3 } from \"@babylonjs/core\";\nimport type { Point2, Point3 } from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\n\nexport function v3(\n  xOrPosition: number | Point3 | Point2 = 0,\n  y: number = 0,\n  z: number = 0\n) {\n  if (typeof xOrPosition === \"number\") {\n    return new Vector3(xOrPosition, y, z);\n  }\n\n  const [xx = 0, yy = 0, zz = 0] = toVec3(xOrPosition as Point3);\n  return new Vector3(xx, yy, zz);\n}\n","import type { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { v3 } from \"../bab/v3\";\n\nexport const updateArcRotateCameraPosition = (\n  camera: ArcRotateCamera,\n  position: Point3\n) => {\n  const currentAlpha = camera.alpha;\n  const currentBeta = camera.beta;\n  const currentRadius = camera.radius;\n  camera.target = camera.target.add(v3(position));\n  camera.radius = currentRadius;\n  camera.alpha = currentAlpha;\n  camera.beta = currentBeta;\n};\n","// import type { ArcRotateCamera } from \"babylonjs\";\n// import { Scene } from \"babylonjs\";\nimport type { AnimateState } from \"@mjt-engine/animate\";\nimport { Inputs } from \"@mjt-engine/input\";\nimport type { Point2 } from \"@mjt-engine/math\";\nimport { Maths, toVec2 } from \"@mjt-engine/math\";\nimport { updateArcRotateCameraPosition } from \"../mesh/updateArcRotateCameraPosition\";\nimport { v3 } from \"../bab/v3\";\nimport type { ArcRotateCamera } from \"@babylonjs/core/Cameras/arcRotateCamera\";\n\nexport const attachArcRotateCameraControls = (\n  camera: ArcRotateCamera,\n  options: Partial<{\n    keySensitivity: number;\n    mouseSensitivity: number;\n    parent: HTMLElement;\n    action: () => void;\n  }> = {}\n): AnimateState[] => {\n  const {\n    keySensitivity = 0.5,\n    mouseSensitivity = 0.05,\n    parent = document.body,\n    action = () => {},\n  } = options;\n\n  const defaultAlpha = camera.alpha;\n  const defaultBeta = camera.beta;\n  const defaultRadius = camera.radius;\n  const defaultTarget = v3(camera.target);\n  const update = (x = 0, y = 0, z = 0) => {\n    updateArcRotateCameraPosition(camera, [x, y, z]);\n    action();\n  };\n\n  const keyAnim = Inputs.listenToKey(\n    {\n      // Y up\n      w: () => {\n        update(-keySensitivity / 2, keySensitivity / 2, 0);\n      },\n      \"shift+w\": () => {\n        camera.radius -= keySensitivity;\n      },\n\n      // X left\n      a: () => {\n        update(-keySensitivity / 2, -keySensitivity / 2, 0);\n      },\n      \"shift+s\": () => {\n        camera.radius += keySensitivity;\n      },\n\n      // Y down\n      s: () => {\n        update(keySensitivity / 2, -keySensitivity / 2, 0);\n      },\n\n      // X right\n      d: () => {\n        update(keySensitivity / 2, keySensitivity / 2, 0);\n      },\n      v: () => {\n        camera.beta = camera.beta + keySensitivity / 8;\n        action();\n      },\n      z: () => {\n        camera.beta = camera.beta - keySensitivity / 8;\n        action();\n      },\n      c: () => {\n        camera.alpha = defaultAlpha;\n        camera.beta = defaultBeta;\n        camera.radius = defaultRadius;\n        action();\n        // camera.target = defaultTarget;\n      },\n      \"shift+d\": () => {\n        camera.alpha = camera.alpha + keySensitivity / 8;\n\n        action();\n      },\n      \"shift+a\": () => {\n        camera.alpha = camera.alpha - keySensitivity / 8;\n\n        action();\n      },\n    },\n    {\n      autoUp: false,\n      parent,\n    }\n  );\n  const MOUSE_STATE = {\n    lastPosition: undefined as Point2 | undefined,\n  };\n  parent.addEventListener(\"pointerdown\", (event) => {\n    if (event.buttons === 4) {\n      MOUSE_STATE.lastPosition = event;\n    }\n  });\n  parent.addEventListener(\"pointermove\", (event) => {\n    if (event.buttons !== 4) {\n      return;\n    }\n    const { lastPosition: auxDownLast = event } = MOUSE_STATE;\n    MOUSE_STATE.lastPosition = event;\n    const diff = Maths.subtract2(auxDownLast, event);\n    const [x, y] = toVec2(diff);\n\n    if (event.buttons === 4 && event.shiftKey) {\n      camera.beta = camera.beta + y * mouseSensitivity;\n      return;\n    }\n\n    if (event.buttons === 4) {\n      update(y * mouseSensitivity, -y * mouseSensitivity, 0);\n      update(x * mouseSensitivity, x * mouseSensitivity, 0);\n    }\n  });\n\n  // zoom\n  const mouseAnim = Inputs.listenToMouse(\n    {\n      wheel: (event) => {\n        if (event instanceof WheelEvent) {\n          const delta = event.deltaY * mouseSensitivity;\n          camera.radius += delta;\n          action();\n        }\n      },\n    },\n    {\n      parent,\n    }\n  );\n  return [keyAnim, mouseAnim];\n};\n","\nexport const createCanvas = ({\n  width = 320, height = 320,\n}: {\n  width: number;\n  height: number;\n}) => {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n};\n","import { Engine } from \"@babylonjs/core\";\nimport type { EngineOptions } from \"@babylonjs/core/Engines/thinEngine\";\nimport { createCanvas } from \"../bab/createCanvas\";\n\nexport type CreateEngineOptions = EngineOptions & {\n  antialias?: boolean;\n  width?: number;\n  height?: number;\n  canvas?: HTMLCanvasElement | OffscreenCanvas;\n};\nexport const createWebGlEngine = (\n  optionsOrCanvas?: CreateEngineOptions | HTMLCanvasElement | OffscreenCanvas\n) => {\n  const options: CreateEngineOptions = !(\n    optionsOrCanvas instanceof HTMLCanvasElement ||\n    optionsOrCanvas instanceof OffscreenCanvas\n  )\n    ? optionsOrCanvas ?? {}\n    : {};\n  const canvas =\n    optionsOrCanvas instanceof HTMLCanvasElement ||\n    optionsOrCanvas instanceof OffscreenCanvas\n      ? optionsOrCanvas\n      : createCanvas({\n          width: optionsOrCanvas?.width ?? 320,\n          height: optionsOrCanvas?.height ?? 320,\n        });\n  const { antialias, xrCompatible = true } = options;\n\n  // const prop\n  const engine = new Engine(canvas, antialias, {\n    powerPreference: \"high-performance\",\n    xrCompatible,\n    ...options,\n  });\n  // engine.loadingScreen = undefined!;\n  engine.hideLoadingUI();\n  return engine;\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport { Matrix } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { ModelMesh } from \"./ModelBuilder\";\n\nexport const pickMesh = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: ModelMesh) => boolean;\n  }> = {}\n) => {\n  const { camera = scene.activeCamera, predicate = () => true } = options;\n  const ray = scene.createPickingRay(x, y, Matrix.Identity(), camera);\n  const hit = scene.pickWithRay(ray, predicate);\n  return hit?.pickedMesh;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\n\nexport const walkMeshes = (\n  mesh: AbstractMesh | Scene,\n  walker: (mesh: AbstractMesh) => void\n): void => {\n  if (mesh instanceof Scene) {\n    return mesh.meshes.forEach((m) => walkMeshes(m, walker));\n  }\n  walker(mesh);\n  mesh.getChildMeshes().forEach((m) => walkMeshes(m, walker));\n};\n","import { Inputs } from \"@mjt-engine/input\";\nimport { isDefined, isUndefined } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport { pickMesh } from \"../model/pickMesh\";\nimport { walkMeshes } from \"../model/walkMeshes\";\nimport type { UniversalCamera } from \"@babylonjs/core\";\n\nexport const attachUniversalCameraControls = (\n  camera: UniversalCamera,\n  options: Partial<{\n    keySensitivity: number;\n    mouseSensitivity: number;\n    parent: HTMLElement;\n  }> = {}\n) => {\n  const {\n    keySensitivity = 0.05,\n    mouseSensitivity = 0.05,\n    parent = document.body,\n  } = options;\n\n  Inputs.listenToKey(\n    {\n      w: () => {\n        camera.position.addInPlace(v3(0, 0, -keySensitivity));\n      },\n      a: () => {\n        camera.rotation.y -= keySensitivity / 2;\n      },\n      s: () => {\n        camera.position.addInPlace(v3(0, 0, keySensitivity));\n      },\n      d: () => {\n        camera.rotation.y += keySensitivity / 2;\n      },\n      i: () => {\n        camera.position.addInPlace(v3(0, keySensitivity, 0));\n      },\n      j: () => {\n        camera.position.addInPlace(v3(keySensitivity, 0, 0));\n      },\n      k: () => {\n        camera.position.addInPlace(v3(0, -keySensitivity, 0));\n      },\n      l: () => {\n        camera.position.addInPlace(v3(-keySensitivity, 0, 0));\n      },\n    },\n    {\n      propagate: false,\n      parent,\n    }\n  );\n\n  Inputs.listenToMouse(\n    {\n      wheel: (event) => {\n        if (event instanceof WheelEvent) {\n          if (event.shiftKey) {\n            const delta = event.deltaX * mouseSensitivity;\n            camera.position.addInPlace(v3(0, -delta, 0));\n            return;\n          }\n\n          const delta = event.deltaY * mouseSensitivity;\n          camera.position.addInPlace(v3(0, 0, delta));\n        }\n      },\n      click: (e) => {\n        if (e.buttons === 0) {\n          const position = e as unknown as HasLayerPosition;\n          const scene = camera.getScene();\n          const mesh = pickMesh(scene, position.layerX, position.layerY);\n          if (isDefined(mesh)) {\n            console.log({ mesh });\n            walkMeshes(scene, (m) => {\n              if (isUndefined(m.material)) {\n                return;\n              }\n              if (m.material) {\n                m.material.wireframe = false;\n              }\n            });\n            if (mesh.material) {\n              mesh.material.wireframe = true;\n            }\n          }\n        }\n      },\n      auxclick: (e) => {\n        if (e.button !== 1) {\n          return;\n        }\n        const scene = camera.getScene();\n        const mesh = pickMesh(scene, e.clientX, e.clientY);\n        if (isUndefined(mesh)) {\n          return;\n        }\n      },\n      contextmenu: (e) => {\n        console.log(\"should context\");\n      },\n    },\n    {\n      propagate: false,\n      parent,\n    }\n  );\n};\n\nexport type HasLayerPosition = { layerX: number; layerY: number };\n","import type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport { UniversalCamera } from \"@babylonjs/core\";\nimport { Camera } from \"@babylonjs/core\";\nimport { BabUniversalCamera } from \"../type/BabCamera\";\n\nexport const createTopDownCamera = (\n  scene: Scene,\n  name: string,\n  {\n    unitsTall = 1,\n    unitsWide = 1,\n    cameraLevel = -100,\n\n    disposeActive = false,\n  }: Partial<{\n    cameraLevel: number;\n    disposeActive: boolean;\n    unitsTall: number;\n    unitsWide: number;\n  }> = {}\n): BabUniversalCamera => {\n  if (disposeActive) {\n    scene?.activeCamera?.dispose();\n  }\n  const camera = new UniversalCamera(name, v3(0, 0, cameraLevel), scene);\n  camera.target = v3(0, 0, 0);\n  camera.rotation = v3(0, 0, Math.PI); // Y up\n  camera.orthoTop = -unitsTall / 2;\n  camera.orthoBottom = unitsTall / 2;\n  camera.orthoLeft = unitsWide / 2;\n  camera.orthoRight = -unitsWide / 2;\n  camera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n  return camera;\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getCamera = <T extends Camera>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const camera = scene.getCameraByName(name);\n  if (isDefined(camera)) {\n    return camera as T;\n  }\n  return producer();\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport type { Camera } from \"@babylonjs/core\";\nimport { TargetCamera } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport type { AllCameraOptions } from \"./Cameras\";\nimport { CAMERA_MODES } from \"./Cameras\";\n\nexport const updateCamera = (camera: Camera, options: AllCameraOptions) => {\n  const {\n    alpha,\n    beta,\n    radius,\n    target,\n    position,\n    rotation,\n    minZ,\n    maxZ,\n    mode,\n    orthoTop,\n    orthoBottom,\n    orthoLeft,\n    orthoRight,\n  } = options;\n  iff(position, (value) => {\n    camera.position = v3(value);\n  });\n  iff(minZ, (value) => {\n    camera.minZ = value;\n  });\n  iff(maxZ, (value) => {\n    camera.maxZ = value;\n  });\n\n  iff(mode, (value) => {\n    camera.mode = CAMERA_MODES[value];\n  });\n\n  iff(mode, (value) => {\n    camera.mode = CAMERA_MODES[value];\n  });\n\n  iff(orthoTop, (value) => {\n    camera.orthoTop = value;\n  });\n\n  iff(orthoBottom, (value) => {\n    camera.orthoBottom = value;\n  });\n\n  iff(orthoLeft, (value) => {\n    camera.orthoLeft = value;\n  });\n\n  iff(orthoRight, (value) => {\n    camera.orthoRight = value;\n  });\n\n  if (camera instanceof TargetCamera) {\n    iff(rotation, (value) => {\n      camera.rotation = v3(value);\n    });\n    iff(target, (value) => {\n      camera.target = v3(value);\n    });\n  }\n\n  if (camera instanceof ArcRotateCamera) {\n    iff(alpha, (value) => {\n      camera.alpha = value;\n    });\n    iff(beta, (value) => {\n      camera.beta = value;\n    });\n    iff(radius, (value) => {\n      camera.radius = value;\n    });\n  }\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type {\n  ArcRotateCameraOptions,\n} from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nexport const getArcRotateCamera = (\n  scene: Scene,\n  name: string,\n  options: ArcRotateCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    const { alpha = 0, beta = 0, radius = 2, target } = options;\n    return new ArcRotateCamera(name, alpha, beta, radius, v3(target), scene);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n\n\n","import { UniversalCamera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { UniversalCameraOptions } from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nexport const getUniversalCamera = (\n  scene: Scene,\n  name: string,\n  options: UniversalCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    const { position } = options;\n    return new UniversalCamera(name, v3(position), scene);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n","import { ArcRotateCamera } from \"@babylonjs/core\";\nimport { Camera } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\n\nexport const createDebugCamera = (scene: Scene, name: string) => {\n  scene?.activeCamera?.dispose();\n  const canvas = scene.getEngine().getRenderingCanvas();\n  const alpha = -Math.PI / 2;\n  const beta = Math.PI / 2.5;\n  const camera = new ArcRotateCamera(name, alpha, beta, 15, v3(0, 0, 0), scene);\n  camera.attachControl(canvas, true);\n  camera.mode = Camera.PERSPECTIVE_CAMERA;\n};\n","import { type Scene, FreeCamera } from \"@babylonjs/core\";\nimport { Babs } from \"../bab/Babs\";\nimport type { FreeCameraOptions } from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\n\nexport const getFreeCamera = (\n  scene: Scene,\n  name: string,\n  options: FreeCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    const { position = [0, 0, 0] } = options;\n    return new FreeCamera(name, Babs.v3(position), scene);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n","import { type Scene, WebXRCamera } from \"@babylonjs/core\";\nimport type { BabWebXRSessionManager, WebXrCameraOptions } from \"./Cameras\";\nimport { getCamera } from \"./getCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\n\nexport const getWebXrCamera = (\n  scene: Scene,\n  name: string,\n  xrSessionManager: BabWebXRSessionManager,\n  options: WebXrCameraOptions = {}\n) => {\n  const camera = getCamera(scene, name, () => {\n    return new WebXRCamera(name, scene, xrSessionManager);\n  });\n  updateCamera(camera, options);\n  return camera;\n};\n","import type { Vec3 } from \"@mjt-engine/math\";\nimport { attachArcRotateCameraControls } from \"./attachArcRotateCameraControls\";\nimport { attachUniversalCameraControls } from \"./attachUniversalCameraControls\";\nimport { createTopDownCamera } from \"./createTopDownCamera\";\nimport { getArcRotateCamera } from \"./getArcRotateCamera\";\nimport { getCamera } from \"./getCamera\";\nimport { getUniversalCamera } from \"./getUniversalCamera\";\nimport { updateCamera } from \"./updateCamera\";\n\nimport { Camera, WebXRSessionManager } from \"@babylonjs/core\";\nimport { createDebugCamera } from \"./createDebugCamera\";\nimport { getFreeCamera } from \"./getFreeCamera\";\nimport { getWebXrCamera } from \"./getWebXrCamera\";\n\nexport const CAMERA_MODES = {\n  orthographic: Camera.ORTHOGRAPHIC_CAMERA,\n  perspective: Camera.PERSPECTIVE_CAMERA,\n};\nexport type CameraModeMap = typeof CAMERA_MODES;\n\nexport type CameraOptions = Partial<{\n  mode: keyof CameraModeMap;\n  position: Vec3;\n  minZ: number;\n  maxZ: number;\n  target: Vec3;\n\n  orthoTop: number;\n  orthoBottom: number;\n  orthoLeft: number;\n  orthoRight: number;\n}>;\nexport type ArcRotateCameraOptions = Partial<\n  CameraOptions & {\n    alpha: number;\n    beta: number;\n    radius: number;\n  }\n>;\n\nexport type UniversalCameraOptions = Partial<\n  CameraOptions & {\n    rotation: Vec3;\n  }\n>;\n\nexport type FreeCameraOptions = Partial<CameraOptions>;\n\nexport type BabXrSession = XRSession;\nexport type BabWebXRSessionManager = WebXRSessionManager;\nexport type WebXrCameraOptions = Partial<CameraOptions>;\n\nexport type AllCameraOptions = ArcRotateCameraOptions & UniversalCameraOptions;\n\nexport const Cameras = {\n  getArcRotateCamera,\n  getCamera,\n  updateCamera,\n  getUniversalCamera,\n  getFreeCamera,\n  getWebXrCamera,\n  attachArcRotateCameraControls,\n  attachUniversalCameraControls,\n  createTopDownCamera,\n  createDebugCamera,\n};\n","import type { Light } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getLight = <T extends Light>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const light = scene.getLightByName(name);\n  if (isDefined(light)) {\n    return light as T;\n  }\n  return producer();\n};\n","import { HemisphericLight } from \"@babylonjs/core\";\nimport type { Light } from \"@babylonjs/core\";\nimport { PointLight } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport { v3 } from \"../bab/v3\";\nimport type { AllLightOptions } from \"./Lights\";\n\nexport const updateLight = (light: Light, options: AllLightOptions) => {\n  const { intensity, direction, position } = options;\n  iff(intensity, (value) => {\n    light.intensity = value;\n  });\n\n  if (light instanceof HemisphericLight) {\n    iff(direction, (value) => {\n      light.direction = v3(value);\n    });\n  }\n\n  if (light instanceof PointLight) {\n    iff(position, (value) => {\n      light.position = v3(value);\n    });\n  }\n};\n","import { HemisphericLight } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { HemisphericLightOptions } from \"./Lights\";\nimport { getLight } from \"./getLight\";\nimport { updateLight } from \"./updateLight\";\n\nexport const getHemisphericLight = (\n  scene: Scene,\n  name: string,\n  options: HemisphericLightOptions = {}\n) => {\n  const light = getLight(scene, name, () => {\n    const { direction } = options;\n    return new HemisphericLight(name, v3(direction), scene);\n  });\n  updateLight(light, options);\n  return light;\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { v3 } from \"../bab/v3\";\nimport type { PointLightOptions } from \"./Lights\";\nimport { getLight } from \"./getLight\";\nimport { updateLight } from \"./updateLight\";\nimport { PointLight } from \"@babylonjs/core\";\n\nexport const getPointLight = (\n  scene: Scene,\n  name: string,\n  options: PointLightOptions = {}\n) => {\n  const light = getLight(scene, name, () => {\n    const { position } = options;\n    return new PointLight(name, v3(position), scene);\n  });\n  updateLight(light, options);\n  return light;\n};\n","import type { Vec3 } from \"@mjt-engine/math\";\nimport { getHemisphericLight } from \"./getHemisphericLight\";\nimport { getLight } from \"./getLight\";\nimport { getPointLight } from \"./getPointLight\";\nimport { updateLight } from \"./updateLight\";\n\nexport type LightOptions = Partial<{ intensity: number }>;\nexport type HemisphericLightOptions = Partial<\n  LightOptions & { direction: Vec3 }\n>;\nexport type PointLightOptions = Partial<LightOptions & { position: Vec3 }>;\n\nexport type AllLightOptions = LightOptions &\n  HemisphericLightOptions &\n  PointLightOptions;\n\nexport const Lights = {\n  getLight,\n  getHemisphericLight,\n  getPointLight,\n  updateLight,\n};\n","import { Color4 } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\n\n\nexport const c4 = (color: string) => {\n  const c = Colors.builder({ color });\n  const result = Color4.FromHexString(c.hex());\n  result.a = c.alpha();\n  return result;\n};\n","import type { InstancedMesh } from \"@babylonjs/core\";\nimport type { Mesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getMesh = <T extends Mesh | InstancedMesh>(\n  scene: Scene,\n  name: string,\n  producer: (instance?: T) => T,\n  updatable: boolean = false\n): T => {\n  const meshMaybe = scene.getMeshByName(name);\n  if (isDefined(meshMaybe) && !updatable) {\n    return meshMaybe as T;\n  }\n  if (isDefined(meshMaybe) && updatable) {\n    return producer(meshMaybe as T) as T;\n  }\n  return producer();\n};\n","import { Color3 } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\n\nexport const c3 = (color: string) => {\n  const hex = Colors.builder({ color }).hex();\n  return Color3.FromHexString(hex);\n};\n","import type { StandardMaterial } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport { iff } from \"@mjt-engine/object\";\nimport { c3 } from \"../bab/c3\";\nimport type { AllMaterialOptions } from \"./Materials\";\n\nexport const updateStandardMaterial = (\n  scene: Scene,\n  material: StandardMaterial,\n  options: AllMaterialOptions\n) => {\n  const {\n    alpha,\n    diffuseTexture,\n    emissiveTexture,\n    ambientTexture,\n    opacityTexture,\n    diffuseColor,\n    specularColor,\n    ambientColor,\n    emissiveColor,\n  } = options;\n\n  iff(diffuseTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.diffuseTexture = texture;\n  });\n  iff(emissiveTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.emissiveTexture = texture;\n  });\n  iff(ambientTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.ambientTexture = texture;\n  });\n  iff(opacityTexture, (value) => {\n    const texture = scene.getTextureByName(value);\n    material.opacityTexture = texture;\n  });\n  iff(diffuseColor, (value) => {\n    material.diffuseColor = c3(value);\n    const colorAlpha = Colors.from(value).alpha();\n    if (colorAlpha < 1) {\n      material.alpha = colorAlpha;\n    }\n  });\n  iff(specularColor, (value) => {\n    material.specularColor = c3(value);\n  });\n  iff(ambientColor, (value) => {\n    material.ambientColor = c3(value);\n  });\n  iff(emissiveColor, (value) => {\n    material.emissiveColor = c3(value);\n  });\n\n  iff(alpha, (value) => {\n    material.alpha = value;\n  });\n};\n","import type { Material } from \"@babylonjs/core\";\nimport { StandardMaterial } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { AllMaterialOptions } from \"./Materials\";\nimport { updateStandardMaterial } from \"./updateStandardMaterial\";\n\nexport const updateMaterial = (\n  scene: Scene,\n  material: Material,\n  options: AllMaterialOptions\n) => {\n  if (material instanceof StandardMaterial) {\n    updateStandardMaterial(scene, material, options);\n  }\n};\n","import { isDefined } from \"@mjt-engine/object\";\nimport type { MaterialTypeMap } from \"./MaterialTypeMap\";\nimport { updateMaterial } from \"./updateMaterial\";\nimport type { AllMaterialOptions } from \"./Materials\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { StandardMaterial } from \"@babylonjs/core\";\nimport { PBRMaterial } from \"@babylonjs/core\";\n\ntype VisualMaterialType = keyof MaterialTypeMap;\n\nexport const getMaterial = <T extends VisualMaterialType = VisualMaterialType>(\n  scene: Scene,\n  name: string,\n  options: T | AllMaterialOptions = \"standard\"\n): MaterialTypeMap[T] => {\n  const material = scene.getMaterialByName(name);\n  if (isDefined(material)) {\n    // updateMaterial(scene, material, options);\n    return material as MaterialTypeMap[T];\n  }\n\n  const type =\n    typeof options === \"string\" ? options : options?.type ?? \"standard\";\n\n  switch (type) {\n    case \"standard\": {\n      const material = new StandardMaterial(name, scene) as MaterialTypeMap[T];\n      updateMaterial(scene, material, options);\n      return material;\n    }\n    case \"pbr\": {\n      const material = new PBRMaterial(name, scene) as MaterialTypeMap[T];\n      updateMaterial(scene, material, options);\n      return material;\n    }\n    default: {\n      throw new Error(`Unknown material type: '${type}'`);\n    }\n  }\n};\n","import { StandardMaterial } from \"@babylonjs/core\";\nimport type { InstancedMesh } from \"@babylonjs/core\";\nimport { Mesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { Point2, Point3 } from \"@mjt-engine/math\";\nimport { iff, isDefined } from \"@mjt-engine/object\";\nimport { c3 } from \"../bab/c3\";\nimport { v3 } from \"../bab/v3\";\nimport { getMaterial } from \"../material/getMaterial\";\n\nexport type MeshOptions = Partial<{\n  position: Point3 | Point2;\n  // texture: string;\n  color: string;\n  material: string;\n  receiveShadows: boolean;\n}>;\n\nexport const updateMesh = (\n  scene: Scene,\n  mesh: Mesh | InstancedMesh,\n  options: MeshOptions\n) => {\n  const { position, color, material, receiveShadows } = options;\n\n  if (mesh instanceof Mesh && isDefined(material)) {\n    mesh.material = getMaterial(scene, material, \"standard\");\n  }\n\n  if (mesh instanceof Mesh && isDefined(receiveShadows)) {\n    mesh.receiveShadows = receiveShadows;\n  }\n\n  iff(position, (p) => {\n    mesh.position = v3(p);\n  });\n\n  iff(color, (c) => {\n    const material = mesh.material;\n    if (material instanceof StandardMaterial) {\n      material.diffuseColor = c3(c);\n      const alpha = Colors.from(c).alpha();\n      if (alpha < 1) {\n        material.alpha = alpha;\n      }\n      material.specularColor = c3(\"black\");\n      material.ambientColor = c3(c);\n      material.emissiveColor = c3(c);\n    }\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { c4 } from \"../bab/c4\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport type BoxOptions = Partial<{\n  width: number;\n  height: number;\n  depth: number;\n  colors: string[];\n}>;\n\nexport const getBox = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions & BoxOptions = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { width = 1, height = 1, depth = 1, colors } = options;\n    const mesh = MeshBuilder.CreateBox(\n      name,\n      {\n        width,\n        height,\n        depth,\n        faceColors: isDefined(colors) ? colors.map(c4) : undefined,\n      },\n      scene\n    );\n\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { Mesh } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isUndefined } from \"@mjt-engine/object\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getBoxInstance = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      width: number;\n      height: number;\n      depth: number;\n      receiveShadows: boolean;\n    }>\n) => {\n  const {\n    width = 1,\n    height = 1,\n    depth = 1,\n    material,\n    receiveShadows = false,\n  } = options;\n  // return getMesh(scene, name, () => {\n  const rootName = `box-instance-root-${JSON.stringify([\n    width,\n    height,\n    depth,\n    material,\n    receiveShadows,\n  ])}`;\n  let rootMesh = scene.getMeshByName(rootName) as Mesh;\n  if (isUndefined(rootMesh)) {\n    rootMesh = MeshBuilder.CreateBox(rootName, { width, height, depth }, scene);\n    rootMesh.receiveShadows = receiveShadows;\n    rootMesh.isVisible = false;\n    if (!material) {\n      throw new Error(\"No material\", { cause: options });\n    }\n    rootMesh.material = getMaterial(scene, material, \"standard\");\n  }\n  const mesh = rootMesh.createInstance(name);\n  updateMesh(scene, mesh, options);\n  return mesh;\n  // });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getSphere = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      radius: number;\n    }>\n) => {\n  const { radius = 0.5 } = options;\n\n  return getMesh(scene, name, () => {\n    const mesh = MeshBuilder.CreateSphere(\n      name,\n      { diameter: radius * 2 },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { Camera } from \"@babylonjs/core\";\nimport { Matrix } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickMesh = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: AbstractMesh) => boolean;\n  }> = {}\n) => {\n  const {\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n    camera = scene.activeCamera,\n  } = options;\n  const ray = scene.createPickingRay(x, y, Matrix.Identity(), camera);\n  const hit = scene.pickWithRay(ray, predicate);\n  return hit?.pickedMesh;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\n\nexport const calcTopOfMeshWorldPosition = (mesh: AbstractMesh) => {\n  mesh.computeWorldMatrix(true);\n  mesh.refreshBoundingInfo({});\n  const [x, y, z] = toVec3(mesh.getAbsolutePosition());\n\n  // const radius = mesh.getBoundingInfo().boundingSphere.radius;\n  const radius = mesh.getBoundingInfo().boundingSphere.radius;\n  // const top = mesh.getBoundingInfo().boundingBox.\n  return [x, y, z - radius] as Point3;\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\n\nexport const walkMeshes = (\n  mesh: AbstractMesh | Scene,\n  walker: (mesh: AbstractMesh) => void\n): void => {\n  if (mesh instanceof Scene) {\n    return mesh.meshes.forEach((m) => walkMeshes(m, walker));\n  }\n  walker(mesh);\n  mesh.getChildMeshes().forEach((m) => walkMeshes(m, walker));\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const BabPolyMap = {\n  tetrahedron: 0,\n  octahedron: 1,\n  dodecahedron: 2,\n  icosahedron: 3,\n  rhombicuboctahadron: 4,\n  triangularPrism: 5,\n  pentagonalPrism: 6,\n  hexagonalPrism: 7,\n  squarePyramid: 8,\n  pentagonalPyramid: 9,\n  triangularDipyramid: 10,\n  pentagonalDipryramid: 11,\n  elongatedSquareDipyramid: 12,\n  elongatedPentagonalDipyramid: 13,\n  elongatedPentagonalCupola: 14,\n};\n\nexport const getPolyhedron = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      size: number;\n      type: keyof typeof BabPolyMap;\n      material: string;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { size = 1, type = \"tetrahedron\" } = options;\n    const mesh = MeshBuilder.CreatePolyhedron(\n      name,\n      { type: BabPolyMap[type], size },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import { Vector3 } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { extent } from \"d3-array\";\n\n/** @see https://forum.babylonjs.com/t/get-mesh-bounding-box-position-and-size-in-2d-screen-coordinates/1058  */\nexport const calcClientRectForMesh = (mesh: AbstractMesh) => {\n  // get bounding box of the mesh\n  const meshVectors = mesh.getBoundingInfo().boundingBox.vectors;\n  const scene = mesh.getScene();\n  const canvas = scene.getEngine().getRenderingCanvas();\n  if (!canvas) {\n    throw new Error(\"No canvas for scene\", { cause: scene });\n  }\n\n  // get the matrix and viewport needed to project the vectors onto the screen\n  const worldMatrix = mesh.getWorldMatrix();\n  const transformMatrix = scene.getTransformMatrix();\n  const viewport = scene.activeCamera!.viewport;\n\n  // loop though all the vectors and project them against the current camera viewport to get a set of coordinates\n  const coordinates = meshVectors.map((v) => {\n    const proj = Vector3.Project(v, worldMatrix, transformMatrix, viewport);\n    proj.x = proj.x * canvas.clientWidth;\n    proj.y = proj.y * canvas.clientHeight;\n    return proj;\n  });\n\n  // get the min and max for all the coordinates so we can calculate the largest possible screen size\n  // using d3.extent\n  const [minX, maxX] = extent(coordinates, (c) => c.x) as number[];\n  const [minY, maxY] = extent(coordinates, (c) => c.y) as number[];\n\n  // return a ClientRect from this\n  const rect = {\n    width: maxX - minX,\n    height: maxY - minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n  };\n\n  return rect;\n};\n","import type { Scene } from \"@babylonjs/core\";\n\nexport const destroyMesh = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    recurse: boolean;\n    disposeMaterials: boolean;\n    disposeTextures: boolean;\n  }> = {}\n) => {\n  const {\n    recurse = true,\n    disposeMaterials = false,\n    disposeTextures = false,\n  } = options;\n  const mesh = scene.getMeshByName(name);\n  if (!mesh) {\n    return;\n  }\n  mesh.dispose(!recurse, false);\n  if (disposeMaterials) {\n    const material = mesh.material;\n    if (!material) {\n      return;\n    }\n    material.name = `DISPOSED-${material.name}`;\n    material?.dispose(true, disposeTextures);\n    scene.removeMaterial(material);\n  }\n  scene.removeMesh(mesh);\n};\n","import type { PickingInfo } from \"@babylonjs/core/Collisions/pickingInfo\";\nimport { isUndefined } from \"@mjt-engine/object\";\n\nexport const findClosestPick = (picks: PickingInfo[]) => {\n  if (isUndefined(picks)) {\n    return undefined;\n  }\n  picks.sort((a, b) => {\n    return a.distance - b.distance;\n  });\n  return picks[0];\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getCylinder = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      height: number;\n      arc: number;\n      radius: number;\n      tag: string | string[];\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { arc = 1, height = 1, radius = 0.5, tag } = options;\n    const mesh = MeshBuilder.CreateCylinder(\n      name,\n      {\n        height,\n        arc,\n        diameter: radius * 2,\n      },\n      scene\n    );\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { LinesMesh } from \"@babylonjs/core/Meshes/linesMesh\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { c4 } from \"../bab/c4\";\nimport { v3 } from \"../bab/v3\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getLine = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      points: Point3[];\n      colors: string[];\n      updatable: boolean;\n      useVertexAlpha: boolean;\n    }>\n) => {\n  const { updatable = false } = options;\n\n  return getMesh(\n    scene,\n    name,\n    (instance: LinesMesh | undefined) => {\n      return buildLineMesh(scene, name, {\n        ...options,\n        instance,\n        // updatable: undefined,\n      });\n    },\n    updatable\n  );\n};\n\nconst buildLineMesh = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      points: Point3[];\n      colors: string[];\n      updatable: boolean;\n      useVertexAlpha: boolean;\n      instance: LinesMesh;\n    }>\n) => {\n  const {\n    colors = [],\n    points = [],\n    color = \"white\",\n    updatable = false,\n    useVertexAlpha,\n    instance,\n  } = options;\n  const pointColors = points\n    .map((_, index) => colors[index] ?? color)\n    .map((c) => c4(c));\n  const fleshedPoints = points.map((p) => v3(p));\n  const mesh = MeshBuilder.CreateLines(name, {\n    points: fleshedPoints,\n    colors: pointColors,\n    updatable,\n    useVertexAlpha,\n    instance,\n  });\n  updateMesh(scene, mesh, options);\n  return mesh;\n};\n","import type { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getMeshAsync = <T extends Mesh | InstancedMesh>(\n  scene: Scene,\n  name: string,\n  producer: () => Promise<T>\n): Promise<T> => {\n  const meshMaybe = scene.getMeshByName(name);\n  if (isDefined(meshMaybe)) {\n    return Promise.resolve(meshMaybe) as Promise<T>;\n  }\n  return producer();\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { getMesh } from \"./getMesh\";\n\nexport const getMeshInstance = <T extends Mesh>(\n  scene: Scene,\n  name: string,\n  rootName: string,\n  producer: () => T\n) => {\n  return getMesh(scene, name, () => {\n    const rootMesh = getMesh(scene, rootName, producer);\n    Asserts.assertValue(rootMesh, () => {\n      console.log({ scene, name, rootName, producer });\n      return \"Unable to create mesh instance. Missing root mesh.\";\n    });\n    return rootMesh.createInstance(name);\n  });\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { getMeshAsync } from \"./getMeshAsync\";\n\nexport const getMeshInstanceAsync = async <T extends Mesh>(\n  scene: Scene,\n  name: string,\n  rootName: string,\n  producer: () => Promise<T>\n) => {\n  return getMeshAsync(scene, name, async () => {\n    const rootMesh = await getMeshAsync(scene, rootName, producer);\n    Asserts.assertValue(rootMesh, () => {\n      console.log({ scene, name, rootName, producer });\n      return \"Unable to create mesh instance. Missing root mesh.\";\n    });\n    return rootMesh.createInstance(name);\n  });\n};\n","import { Mesh } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getPlane = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      width: number;\n      height: number;\n      tag: string | string[];\n      billboard: boolean;\n      doubleSided: boolean;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { width = 1, height = 1, tag, doubleSided  } = options;\n    const mesh = MeshBuilder.CreatePlane(\n      name,\n      {\n        width,\n        height,\n        sideOrientation: doubleSided ? Mesh.DOUBLESIDE : undefined,\n      },\n      scene\n    );\n    const { billboard } = options;\n    if (billboard) {\n      mesh.billboardMode = Mesh.BILLBOARDMODE_ALL;\n    }\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { getMesh } from \"./getMesh\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getTorusKnot = (\n  scene: Scene,\n  name: string,\n  options: MeshOptions &\n    Partial<{\n      radius: number;\n      material: string;\n    }> = {}\n) => {\n  return getMesh(scene, name, () => {\n    const { radius = 0.5 } = options;\n    const mesh = MeshBuilder.CreateTorusKnot(name, { radius }, scene);\n    updateMesh(scene, mesh, options);\n    return mesh;\n  });\n};\n","import type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport type { Point3} from \"@mjt-engine/math\";\nimport { toVec3 } from \"@mjt-engine/math\";\nimport { tuple2, tuple3 } from \"@mjt-engine/object\";\n\nexport type Point3ColorIndex = [Point3, number];\n\nexport const voxDataToCorrectedPoints = (voxData: VoxData) => {\n  const { XYZI, SIZE } = voxData;\n  const scale = SIZE.z;\n  const xVoxelCenterCorrection = 1 / scale / 2;\n  const yVoxelCenterCorrection = 1 / scale / 2;\n  // const zVoxelCenterCorrection = (1 / scale) * 2 + 1 / scale / 2;\n  const zVoxelCenterCorrection = 1 / scale / 2;\n  return XYZI.map((xyzi) => {\n    const [x, y, z] = toVec3(xyzi);\n\n    const xx = (x - SIZE.x / 2) / scale + xVoxelCenterCorrection;\n    const yy = (y - SIZE.y / 2) / scale + yVoxelCenterCorrection;\n\n    // TODO make +z 'up'\n    const zz = (z - SIZE.z / 2) / -scale - zVoxelCenterCorrection;\n\n    return tuple2(tuple3(xx, yy, zz), xyzi.i);\n  });\n};\n","import { MeshBuilder } from \"@babylonjs/core\";\nimport { SolidParticleSystem } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { c3 } from \"../bab/c3\";\nimport { c4 } from \"../bab/c4\";\nimport { v3 } from \"../bab/v3\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport { voxDataToCorrectedPoints } from \"./voxDataToCorrectedPoints\";\n\nexport const voxDataToSps = (scene: Scene, voxData: VoxData, name: string) => {\n  const { XYZI, RGBA, SIZE } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n\n  const sps = new SolidParticleSystem(name, scene);\n  const scale = 1 / SIZE.z;\n  const box = MeshBuilder.CreateBox(\"temp-box\", {\n    width: scale,\n    height: scale,\n    depth: scale,\n  });\n  sps.addShape(box, XYZI.length);\n  sps.buildMesh();\n  box.dispose();\n  voxDataToCorrectedPoints(voxData).forEach((pc, index) => {\n    const [point, colorIndex] = pc;\n    const particle = sps.particles[index];\n    particle.position = v3(point);\n\n    const color = colors[colorIndex];\n    particle.color = c4(color);\n  });\n  const material = getMaterial(scene, \"vox-material\", \"standard\");\n  // const material = Visuals.getMaterial(scene, \"vox-material\", \"pbr\");\n  // material.\n  material.specularColor = c3(\"black\");\n  sps.mesh.material = material;\n\n  sps.setParticles();\n  return sps;\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { isUndefined } from \"@mjt-engine/object\";\nimport { voxDataToSps } from \"../voxel/voxDataToSps\";\nimport type { MeshOptions } from \"./updateMesh\";\nimport { updateMesh } from \"./updateMesh\";\n\nexport const getVoxModel = (\n  scene: Scene,\n  name: string,\n  src: string,\n\n  options: MeshOptions &\n    Partial<{\n      merged: boolean;\n    }> = {}\n) => {\n  // return getMesh(scene, name, () => {\n  const metadata = scene.metadata ?? {};\n  const { voxes = {} } = metadata;\n  const voxData = voxes[src];\n  if (isUndefined(voxData)) {\n    console.log({ scene, name, src });\n    throw new Error(`No voxData found for ${src} ${name}`);\n  }\n\n  const sps = voxDataToSps(scene, voxData, name);\n  const mesh = sps.mesh;\n\n  // sps.mesh.setEnabled(false);\n\n  // const { merged = true } = options;\n  // const mesh = merged\n  //   ? voxDataToMergedModel(scene, voxData, name)\n  //   : voxDataToComplexModel(scene, voxData, name);\n\n  updateMesh(scene, mesh, options);\n  return sps;\n  // });\n};\n","import type { AbstractMesh } from \"@babylonjs/core\";\nimport { InstancedMesh } from \"@babylonjs/core\";\n\nexport const isInstancedMesh = (mesh: AbstractMesh): mesh is InstancedMesh => {\n  return mesh instanceof InstancedMesh;\n};\n","import type { Point2} from \"@mjt-engine/math\";\nimport { Maths, toVec2 } from \"@mjt-engine/math\";\n\n\nexport const lookAt = (from: Point2, to: Point2) => {\n  const [x, y] = toVec2(Maths.normalize2(Maths.subtract2(to, from)));\n  return Math.atan2(y, x) + Math.PI / 2;\n};\n","import { Mesh } from \"@babylonjs/core\";\n\nexport const mergeMeshes = (\n  meshes: Mesh[],\n  options: Partial<{\n    disposeSource: boolean;\n    allow32BitsIndices: boolean;\n    meshSubclass: Mesh;\n    subdivideWithSubMeshes: boolean;\n    multiMultiMaterials: boolean;\n  }> = {}\n) => {\n  const {\n    disposeSource = false,\n    allow32BitsIndices = true,\n    meshSubclass = undefined,\n    subdivideWithSubMeshes = false,\n    multiMultiMaterials = false,\n  } = options;\n  const mergedMesh = Mesh.MergeMeshes(\n    meshes as Mesh[],\n    disposeSource,\n    allow32BitsIndices,\n    meshSubclass,\n    subdivideWithSubMeshes,\n    multiMultiMaterials\n  );\n\n  return mergedMesh;\n};\n","import type { Camera } from \"@babylonjs/core/Cameras/camera\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickMeshes = (\n  scene: Scene,\n  x: number,\n  y: number,\n  options: Partial<{\n    camera: Camera;\n    predicate: (mesh: AbstractMesh) => boolean;\n  }> = {}\n) => {\n  const {\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n    camera = scene.activeCamera,\n  } = options;\n  if (!camera) {\n    throw new Error(\"Camera required\");\n  }\n  return scene.multiPick(x, y, predicate, camera);\n};\n","import type { PBRMaterial } from \"@babylonjs/core\";\nimport { Texture } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const describeMesh = (mesh: AbstractMesh, search = /.*/, depth = 0) => {\n  const padding = \"\".padStart(depth * 2);\n  if (search.test(mesh.name)) {\n    console.log(`${padding}mesh: '${mesh.name}'`);\n    const material = mesh.material as PBRMaterial;\n    if (isDefined(material)) {\n      const entries = Object.entries(material).filter((e) =>\n        /.Texture$/.test(e[0])\n      );\n      entries.map((entry) => {\n        const [key, value] = entry;\n        if (value instanceof Texture && key !== \"_environmentBRDFTexture\") {\n          console.log(`${padding}tex: '${value.name}' (${key})`);\n        }\n      });\n    }\n  }\n\n  mesh.getChildMeshes().map((m) => describeMesh(m, search, depth + 1));\n};\n","import { getBox } from \"./getBox\";\nimport { getBoxInstance } from \"./getBoxInstance\";\nimport { getSphere } from \"./getSphere\";\nimport { pickMesh } from \"./pickMesh\";\nimport { calcTopOfMeshWorldPosition } from \"./calcTopOfMeshWorldPosition\";\nimport { walkMeshes } from \"./walkMeshes\";\nimport { getPolyhedron } from \"./getPolyhedron\";\n\n// BS babylonjs 'magic'\n// import \"@babylonjs/core/Debug/debugLayer\";\n// import \"@babylonjs/inspector\";\n// import \"babylonjs-inspector\";\n// import \"babylonjs/Debug/debugLayer\";\n\nimport { calcClientRectForMesh } from \"./calcClientRectForMesh\";\nimport { destroyMesh } from \"./destroyMesh\";\nimport { findClosestPick } from \"./findClosestPick\";\nimport { getCylinder } from \"./getCylinder\";\nimport { getLine } from \"./getLine\";\nimport { getMesh } from \"./getMesh\";\nimport { getMeshAsync } from \"./getMeshAsync\";\nimport { getMeshInstance } from \"./getMeshInstance\";\nimport { getMeshInstanceAsync } from \"./getMeshInstanceAsync\";\nimport { getPlane } from \"./getPlane\";\nimport { getTorusKnot } from \"./getTorusKnot\";\nimport { getVoxModel } from \"./getVoxModel\";\nimport { isInstancedMesh } from \"./isInstancedMesh\";\nimport { lookAt } from \"./lookAt\";\nimport { mergeMeshes } from \"./mergeMeshes\";\nimport { pickMeshes } from \"./pickMeshes\";\nimport { updateArcRotateCameraPosition } from \"./updateArcRotateCameraPosition\";\nimport { updateMesh } from \"./updateMesh\";\nimport { describeMesh } from \"./describeMesh\";\nexport const Meshes = {\n  lookAt,\n  getBox,\n  describeMesh,\n  getPlane,\n  getBoxInstance,\n  getSphere,\n  getCylinder,\n  getTorusKnot,\n  getLine,\n  walkMeshes,\n  pickMesh,\n  getMesh,\n  getMeshAsync,\n  calcTopOfMeshWorldPosition,\n  mergeMeshes,\n  getVoxModel,\n  calcClientRectForMesh,\n  updateArcRotateCameraPosition,\n  findClosestPick,\n  destroyMesh,\n  getMeshInstance,\n  getMeshInstanceAsync,\n  isInstancedMesh,\n  pickMeshes,\n  getPolyhedron,\n  updateMesh,\n};\n","import { Scene } from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const createScene = (engine: BabEngine) => {\n  return new Scene(engine);\n};\n","import { isDefined, isUndefined } from \"@mjt-engine/object\";\n\nlet depth = 0;\n\nconst STYLE = \"background: #222; color: #bada55\";\nexport const enabled = false;\nexport const stopwatch = (label: string) => {\n  const padding = \"\".padStart(depth * 2);\n  depth += 1;\n  label = padding + label;\n  if (enabled) {\n    console.log(`%c${label} start`, STYLE);\n  }\n\n  const start = Date.now();\n\n  return (checkpoint?: string) => {\n    const time = Date.now() - start;\n    const labelCheckpoint = [label, checkpoint ?? \"\"].join(\" \");\n    if (enabled) {\n      console.log(`%c${labelCheckpoint} ${(time / 1000).toFixed(2)}`, STYLE);\n      if (isUndefined(checkpoint)) {\n        depth -= 1;\n      }\n    }\n  };\n};\n\n// export function time<T>(expr: () => T, label: string): T;\n// export async function time<T>(\n//   expr: () => Promise<T>,\n//   label: string\n// ): Promise<T>;\n\nexport function time<T>(expr: () => T, label = expr.name): T {\n  const sw = stopwatch(label);\n  const result = expr();\n  sw();\n  return result;\n}\n\nexport async function timeP<T>(\n  expr: () => Promise<T>,\n  label = expr.name\n): Promise<T> {\n  const sw = stopwatch(label);\n  const result = await expr();\n  sw();\n  return result;\n}\n\nexport const Timers = {\n  time,\n  timeP,\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { stopwatch } from \"../util/Timers\";\n\nexport const renderOnce = (scene: Scene): Promise<void> => {\n  const sw = stopwatch(`renderOnce`);\n  return new Promise((resolve, reject) => {\n    try {\n      scene.onAfterRenderCameraObservable.addOnce(() => {\n        sw();\n        resolve();\n      });\n      scene.render(true);\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import type { Scene } from \"@babylonjs/core\";\n\n// babylon magic BS\nimport \"@babylonjs/core\";\nimport \"@babylonjs/inspector\";\n\nexport const toggleInspector = (scene: Scene) => {\n  if (scene.debugLayer.isVisible()) {\n    scene.debugLayer.hide();\n  } else {\n    scene.debugLayer.show();\n  }\n};\n","import { createScene } from \"./createScene\";\nimport { renderOnce } from \"./renderOnce\";\nimport { toggleInspector } from \"./toggleInspector\";\n\nexport const Scenes = {\n  createScene,\n  toggleInspector,\n  renderOnce,\n};\n","import { Scene as BabScene } from \"@babylonjs/core\";\nimport { BabEnvironmentHelper } from \"./WxrsTypes\";\n\nexport const createDefaultEnvironment = (\n  scene: BabScene\n): BabEnvironmentHelper => {\n  const env = scene.createDefaultEnvironment();\n  if (!env) {\n    throw new Error(\"Failed to create default environment\");\n  }\n  return env;\n};\n","import { Scene as BabScene } from \"@babylonjs/core\";\nimport {\n  BabWebXrDefaultExperience,\n  BabWebXRDefaultExperienceOptions,\n} from \"./WxrsTypes\";\n\nexport const createWebXrExperience = async (\n  scene: BabScene,\n  options: BabWebXRDefaultExperienceOptions = {}\n): Promise<BabWebXrDefaultExperience> => {\n  return scene.createDefaultXRExperienceAsync(options);\n};\n","import { Cameras } from \"../camera/Cameras\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { Lights } from \"../light/Lights\";\nimport { Meshes } from \"../mesh/Meshes\";\nimport { Scenes } from \"../scene/Scenes\";\nimport { BabEngine } from \"../type/BabEngine\";\nimport { createDefaultEnvironment } from \"./createDefaultHelper\";\nimport { createWebXrExperience } from \"./createWebXrExperience\";\n\nexport const helloXrWorld = async (engine: BabEngine = createWebGlEngine()) => {\n  const scene = Scenes.createScene(engine);\n  const camera = Cameras.getFreeCamera(scene, \"camera1\", {\n    position: [0, 5, -10],\n    target: [0, 0, 0],\n  });\n  const canvas = engine.getRenderingCanvas();\n  camera.attachControl(canvas, true);\n  const light = Lights.getHemisphericLight(scene, \"light1\", {\n    direction: [0, 1, 0],\n    intensity: 0.7,\n  });\n\n  const sphere = Meshes.getSphere(scene, \"sphere\", {\n    radius: 1,\n    position: [0, 1, 0],\n  });\n\n  const env = createDefaultEnvironment(scene);\n  if (!env?.ground) {\n    throw new Error(\"Failed to create default environment\");\n  }\n\n  const xr = createWebXrExperience(scene, {\n    floorMeshes: [env.ground],\n  });\n\n  engine.runRenderLoop(() => {\n    scene.render();\n  });\n\n  return { scene, xr };\n};\n","import { Scene } from \"@babylonjs/core\";\nimport { Cameras } from \"../camera/Cameras\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { Lights } from \"../light/Lights\";\nimport { Meshes } from \"../mesh/Meshes\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const helloWorld = (engine: BabEngine = createWebGlEngine()) => {\n  const scene = new Scene(engine);\n  const canvas = engine.getRenderingCanvas();\n\n  const camera = Cameras.getArcRotateCamera(scene, \"Camera\", {});\n  camera.attachControl(canvas, true);\n  Lights.getHemisphericLight(scene, \"light1\", {\n    direction: [1, 1, 1],\n  });\n  Meshes.getSphere(scene, \"sphere\", {\n    radius: 0.5,\n  });\n  // hide/show the Inspector\n  const STATE = { debug: false };\n  canvas!.onkeyup = (ev) => {\n    // ctrl+I\n    if (ev.ctrlKey && ev.keyCode === 73) {\n      STATE.debug = !STATE.debug;\n      if (STATE.debug) {\n        scene.debugLayer.hide();\n      } else {\n        console.log(\"SHOW!\");\n        scene.debugLayer.show();\n      }\n    }\n  };\n\n  // run the main render loop\n  engine.runRenderLoop(() => {\n    scene.render();\n  });\n  return scene;\n};\n","import { attachArcRotateCameraControls } from \"../camera/attachArcRotateCameraControls\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { helloXrWorld } from \"../wxr/hellowXrWorld\";\nimport { c3 } from \"./c3\";\nimport { c4 } from \"./c4\";\nimport { createCanvas } from \"./createCanvas\";\nimport { helloWorld } from \"./helloWorld\";\nimport { v3 } from \"./v3\";\n\nexport const Babs = {\n  createEngine: createWebGlEngine,\n  createCanvas,\n  v3,\n  c3,\n  c4,\n  helloWorld,\n  helloXrWorld,\n  attachEditorControls: attachArcRotateCameraControls,\n};\n","import { WebGPUEngine, WebGPUEngineOptions } from \"@babylonjs/core\";\n\nexport const createWebGpuEngine = async ({\n  canvas,\n  ...rest\n}: { canvas: HTMLCanvasElement | OffscreenCanvas } & WebGPUEngineOptions) => {\n  const engine = new WebGPUEngine(canvas, {\n    // powerPreference: \"high-performance\",\n    ...rest,\n  });\n  engine.hideLoadingUI();\n  await engine.initAsync();\n  return engine;\n};\n","import { WebGPUEngine } from \"@babylonjs/core\";\n\n\nexport const isWebGpuCapable = () => {\n  return WebGPUEngine.IsSupportedAsync;\n};\n","import { createWebGlEngine } from \"./createWebglEngine\";\nimport { createWebGpuEngine } from \"./createWebGpuEngine\";\nimport { isWebGpuCapable } from \"./isWebGpuCapable\";\n\nexport const Engines = {\n  createWebGlEngine,\n  createWebGpuEngine,\n  isWebGpuCapable,\n};\n","import { Color3 } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { ModelMaterial } from \"../ModelBuilder\";\n\nexport const fixEyelashes = (scene: Scene) => {\n  console.log(\"fixing eyelashes\", scene.meshes);\n  scene.meshes.forEach((mesh) => {\n    if (mesh.name.includes(\"Eyelashes\")) {\n      console.log(\"fixing eyelashes\", mesh.name);\n      // mesh.setEnabled(false); // TODO re-enable eyelashes when morphs fixed\n      if (mesh.name.includes(\"primitive1\")) {\n        console.log(\"fixing eyelashes: primitive1\", mesh.name);\n        const material = mesh.material as ModelMaterial;\n        if (!material) {\n          throw new Error(\"Mesh has no material\", { cause: mesh });\n        }\n        const texture = material.getActiveTextures()[0];\n        texture.hasAlpha = true;\n        texture.getAlphaFromRGB = true;\n        material.transparencyMode = 1;\n        material.opacityTexture = texture;\n        mesh.visibility = 0.5;\n        material.albedoColor = new Color3(0, 0, 0);\n      }\n    }\n  });\n};\n","import type { PBRMaterial } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nexport const HIDE = [\n  // \"Irises\",\n  // \"Pupils\",\n  // \"Sclera\", // 'red' of the eye\n  // \"Cornea\",\n  // \"Eyelashes\",\n  // \"EyeMoisture\",\n  // \"EyeSocket\",\n  // \"Face\",\n  // \"Teeth\",\n  // \"Lips\",\n  // \"Mouth\",\n  // \"Ears\",\n  // \"Torso\",\n];\n\nexport const GLOSS = [\n  \"Irises\",\n  \"Pupils\",\n  \"Sclera\",\n  // \"Eyelashes\",\n  // \"EyeSocket\",\n  // \"Face\",\n  // \"Teeth\",\n  // \"Lips\",\n  // \"Mouth\",\n  // \"Ears\",\n  // \"Torso\",\n];\n\nexport const fixEyes = (mesh: AbstractMesh) => {\n  // console.log(mesh.name);\n  const textures = mesh?.material?.getActiveTextures() ?? [];\n  // textures.map((t) => console.log(\"texture: \" + t?.name));\n  if (\n    isDefined(\n      textures.find((t) => {\n        const name = t?.name;\n        return isDefined(HIDE.find((h) => name.includes(h)));\n      })\n    )\n  ) {\n    mesh.visibility = 0;\n  }\n\n  // gloss meshes\n  if (\n    isDefined(\n      textures.find((t) => {\n        const name = t?.name;\n        return isDefined(GLOSS.find((h) => name.includes(h)));\n      })\n    )\n  ) {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 1;\n    material.transparencyMode = 2;\n\n    // material.subSurface.isScatteringEnabled = true;\n    // material.subSurface.scatteringDiffusionProfile = c3(\"white\");\n    // material.albedoTexture.hasAlpha = true;\n    // material.roughness = 0.5;\n    // material.albedoColor = c3('green')\n    // material.emissiveIntensity = 1;\n    // material.emissiveColor = c3(\"white\");\n    // material.emissiveTexture = material.albedoTexture;\n    // material.roughness = 0;\n    if (material.albedoTexture) {\n      material.albedoTexture.hasAlpha = true;\n    }\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.2;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    material.opacityTexture = material.albedoTexture;\n    // mesh.visibility = 0;\n    // material.emissiveTexture = material.albedoTexture;\n    // material.albedoColor = c3(\"red\");\n  }\n\n  // moisture?\n  if (mesh.name === \"Genesis8Female.Shape_primitive10\") {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 0;\n    mesh.visibility = 0;\n    // // material.zOffset = -1;\n    // // material.roughness = 0.5;\n    // // material.clearCoat.isEnabled = true;\n    // // material.clearCoat.intensity = 1;\n    // // material.useLogarithmicDepth = true;\n\n    // // material.subSurface.isScatteringEnabled = true;\n    // // material.subSurface.scatteringDiffusionProfile = c3(\"grey\");\n\n    // material.transparencyMode = 2;\n    // material.clearCoat.isEnabled = true;\n    // material.clearCoat.intensity = 0.3;\n    // material.subSurface.isTranslucencyEnabled = true;\n    // material.subSurface.translucencyIntensity = 1;\n    // material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // // material.albedoTexture.hasAlpha = true;\n\n    // // visibility controls the 'redness' of the eyes\n    // mesh.visibility = 0.4;\n    // // mesh.setEnabled(false);\n  }\n\n  // pupil mask (water layer)\n  if (mesh.name === \"Genesis8Female.Shape_primitive12\") {\n    const material = mesh.material as PBRMaterial;\n    // material.metallic = 1;\n    material.roughness = 0;\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.5;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // can have the 'effect' of clouding/ disapering the iris/pupil\n    mesh.visibility = 0;\n    mesh.setEnabled(false);\n    // mesh.visibility = 1;\n  }\n\n  // iris\n  if (mesh.name === \"Genesis8Female.Shape_primitive13\") {\n    const material = mesh.material as PBRMaterial;\n    material.metallic = 0;\n  }\n\n  // sclarera\n  if (mesh.name === \"Genesis8Female.Shape_primitive14\") {\n    const material = mesh.material as PBRMaterial;\n    material.opacityTexture = null;\n    material.metallic = 0;\n    material.useAlphaFromAlbedoTexture = false;\n    if (material.albedoTexture) {\n      material.albedoTexture.level = 3;\n    }\n  }\n  // bottom edge of eyelid\n  if (mesh.name.endsWith(\"Eyelashes.Shape_primitive0\")) {\n    const material = mesh.material as PBRMaterial;\n    // material.metallic = 1;\n    material.roughness = 0.5;\n    material.clearCoat.isEnabled = true;\n    material.clearCoat.intensity = 0.5;\n    material.subSurface.isTranslucencyEnabled = true;\n    material.subSurface.translucencyIntensity = 0.5;\n    material.subSurface.translucencyIntensityTexture = material.albedoTexture;\n    // material.albedoColor = new Color3(0.5, 0.5, 0.5);\n    mesh.visibility = 0.2;\n    // mesh.visibility = 0.5;\n    // mesh.visibility = 0.5;\n  }\n\n  mesh.getChildMeshes().map(fixEyes);\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport type { ModelMaterial } from \"../ModelBuilder\";\n\nexport const fixBumpMaps = (scene: Scene) => {\n  console.log(\"fixing bump maps\", scene.meshes);\n  scene.meshes.forEach((mesh) => {\n    // mesh.setEnabled(false); // TODO re-enable eyelashes when morphs fixed\n    const material = mesh.material as ModelMaterial;\n    if (!material) {\n      return;\n    }\n    material.bumpTexture = null;\n  });\n};\n","import type { Scene } from \"@babylonjs/core\";\nimport { fixEyelashes } from \"./fixEyelashes\";\nimport { fixEyes } from \"./fixEyes\";\nimport { fixBumpMaps } from \"./fixBumpMaps\";\n\nexport const fixDazFigure = (scene: Scene) => {\n  fixEyelashes(scene);\n  scene.meshes.map(fixEyes);\n  fixBumpMaps(scene);\n};\n","import { SceneLoader } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n// import { GLTF2 } from \"@babylonjs/loaders/glTF\";\nimport { fixDazFigure } from \"./fix/fixDazFigure\";\n\n/** WARNING!!!!!!\n * \n * YOU MUST LOAD THE GLTF2 LOADER FIRST!!!\n * import { GLTF2 } from \"@babylonjs/loaders/glTF\";\n * \n */\nexport const loadDazFigure = (props: {\n  path: string | File;\n  scene: Scene;\n  name?: string;\n}): Promise<AbstractMesh> => {\n  const { path, scene, name = path instanceof File ? path.name : path } = props;\n  const engine = scene.getEngine();\n  engine.hideLoadingUI();\n\n  return new Promise((resolve, reject) => {\n    try {\n      // GLTF2.GLTFLoader; // fucking loader 'magic'\n      SceneLoader.ShowLoadingScreen = false;\n\n      SceneLoader.Append(\n        \"\",\n        path,\n        scene,\n        (loadedScene) => {\n          const rootMesh = loadedScene.getMeshByName(\"__root__\");\n          if (!rootMesh) {\n            throw new Error(\"No root mesh found\", { cause: loadedScene });\n          }\n          rootMesh.name = name;\n          if (loadedScene.cameras.length > 0) {\n            loadedScene.activeCamera = loadedScene.cameras[0];\n          }\n          loadedScene.animationGroups.forEach((anim) => {\n            anim.stop();\n          });\n          fixDazFigure(loadedScene);\n\n          resolve(rootMesh);\n        },\n        (progress) => {},\n        (scene, message, reason) => {\n          console.log({ path, scene, message, reason });\n          reject(reason);\n        }\n      );\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import { renderOnce } from \"../scene/renderOnce\";\nimport { builder } from \"./builder\";\nimport { fixDazFigure } from \"./fix/fixDazFigure\";\nimport { loadAssetContainer } from \"./loadAssetContainer\";\nimport { loadDazFigure } from \"./loadDazFigure\";\n\nexport const Models = {\n  renderOnce,\n  loadDazFigure,\n  // fixDazFigure,\n  // loadAssetContainer,\n  // builder,\n};\n","export const copyToCanvas = (\n  image: HTMLCanvasElement | OffscreenCanvas | HTMLImageElement,\n  width = image.width,\n  height = image.height\n) => {\n  const copy = document.createElement(\"canvas\");\n  copy.width = width;\n  copy.height = height;\n  copy\n    .getContext(\"2d\")!\n    .drawImage(\n      image as HTMLCanvasElement,\n      0,\n      0,\n      image.width,\n      image.height,\n      0,\n      0,\n      copy.width,\n      copy.height\n    );\n  return copy;\n};\n","import { Images } from \"@mjt-engine/image\";\nimport type { TextureImageSrc } from \"../texture/TextureImageSrc\";\nimport { stopwatch } from \"./Timers\";\n\nexport const imageSrcToUrl = async (src: TextureImageSrc): Promise<string> => {\n  const sw = stopwatch(\"imageSrcToUrl\");\n  if (typeof src === \"string\") {\n    sw();\n    return src;\n  }\n\n  // const flipped = await createImageBitmap(src, {\n  //   imageOrientation: \"flipY\",\n  // });\n  const cvs = document.createElement(\"canvas\");\n  cvs.width = src.width;\n  cvs.height = src.height;\n  cvs.getContext(\"2d\")!.drawImage(src, 0, 0);\n  const result = await Images.toSrcString(cvs);\n  sw();\n  return result;\n};\n","import { DynamicTexture } from \"@babylonjs/core\";\nimport { Texture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { imageSrcToUrl } from \"../util/imageSrcToUrl\";\n\nexport const imageToTexture = async (\n  scene: Scene,\n  name: string,\n  image: string | HTMLImageElement | HTMLCanvasElement | OffscreenCanvas\n): Promise<Texture> => {\n  if (image instanceof HTMLCanvasElement) {\n    return new Promise((resolve, reject) => {\n      try {\n        const texture = new DynamicTexture(name, image, scene);\n        texture.update();\n        texture.hasAlpha = true;\n        resolve(texture);\n      } catch (reason) {\n        reject(reason);\n      }\n    });\n  }\n\n  const url = await imageSrcToUrl(image);\n  return new Promise((resolve, reject) => {\n    try {\n      const texture = new Texture(url, scene, false, true);\n      texture.name = name;\n      texture.hasAlpha = true;\n      texture.onLoadObservable.addOnce(() => {\n        resolve(texture);\n      });\n    } catch (reason) {\n      reject(reason);\n    }\n  });\n};\n","import { StandardMaterial } from \"@babylonjs/core\";\nimport { MeshBuilder } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { Randoms } from \"@mjt-engine/random\";\nimport { c3 } from \"../bab/c3\";\nimport type { TextureImageSrc } from \"./TextureImageSrc\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { imageToTexture } from \"./imageToTexture\";\n\nexport const hasValidId = (obj: { id: string | number } | string) => {\n  if (typeof obj === \"string\") {\n    return true;\n  }\n  return isDefined(obj.id) && String(obj.id).startsWith(\"id-\");\n};\n\nexport const idOfImageSrc = (src: TextureImageSrc) => {\n  if (typeof src === \"string\") {\n    return src;\n  }\n  if (\"id\" in src) {\n    return src.id;\n  }\n  return undefined;\n};\n\nexport const layerToPlane = async (layer: TextureLayer, scene: Scene) => {\n  const id = Randoms.randomUuid();\n  const { size, image, color } = layer;\n  const plane = MeshBuilder.CreatePlane(\n    `plane-${id}`,\n    {\n      width: size,\n      height: size,\n    },\n    scene\n  );\n  const material = new StandardMaterial(`material-${id}`, scene);\n  if (isDefined(image)) {\n    const texture = await imageToTexture(scene, `layer-${id}`, image);\n    layer._texture = texture;\n    layer._mesh = plane;\n    layer._material = material;\n\n    texture.hasAlpha = true;\n    material.opacityTexture = texture;\n    material.emissiveTexture = texture;\n  }\n\n  if (isDefined(color)) {\n    material.emissiveColor = c3(color);\n  }\n\n  plane.material = material;\n  return plane;\n};\n","import type { Engine } from \"@babylonjs/core\";\nimport { Scene } from \"@babylonjs/core\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { layerToPlane } from \"./layerToPlane\";\n\nexport const imageLayersToScene = async (\n  layers: TextureLayer[],\n  engine: Engine\n) => {\n  const scene = new Scene(engine);\n  const planes = await Promise.all(\n    layers.map(async (image, index) => {\n      const plane = await layerToPlane(image, scene);\n      plane.position.set(0, 0, -index);\n      return plane;\n    })\n  );\n  return scene;\n};\n","import { Camera } from \"@babylonjs/core\";\nimport { UniversalCamera } from \"@babylonjs/core\";\nimport { createWebGlEngine } from \"../engine/createWebglEngine\";\nimport { renderOnce } from \"../scene/renderOnce\";\nimport { v3 } from \"../bab/v3\";\nimport { timeP } from \"../util/Timers\";\nimport type { TextureLayer } from \"./TextureLayer\";\nimport { copyToCanvas } from \"./copyToCanvas\";\nimport { imageLayersToScene } from \"./imageLayersToScene\";\n\nexport const builder = ({ size } = { size: 4096 }): TextureBuilder => {\n  const engine = createWebGlEngine({ width: size, height: size });\n  const canvas = engine.getRenderingCanvas();\n  const STATE = {\n    layers: [] as TextureLayer[],\n  };\n  const b: TextureBuilder = {\n    addLayer: (layer) => {\n      STATE.layers.push({ size, ...layer });\n      return b;\n    },\n    render: async () => {\n      return timeP(async () => {\n        const scene = await imageLayersToScene(STATE.layers, engine);\n        const camera = new UniversalCamera(\"camera1\", v3(0, 0, -1000), scene);\n        camera.setTarget(v3());\n        camera.rotation = v3(0, 0, Math.PI);\n        camera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n        camera.minZ = 0;\n        camera.maxZ = 100000;\n\n        await renderOnce(scene);\n        b.clear();\n        if (!canvas) {\n          throw new Error(\"No canvas found\", { cause: engine });\n        }\n        return copyToCanvas(canvas);\n      }, \"Texture render\");\n    },\n    clear: () => {\n      STATE.layers.forEach((layer) => {\n        if (layer?._cached) {\n          return;\n        }\n        layer?._texture?.dispose();\n        layer?._mesh?.dispose();\n        layer?._material?.dispose();\n      });\n      STATE.layers.length = 0;\n      return b;\n    },\n  };\n\n  return b;\n};\n\nexport type TextureBuilder = {\n  addLayer: (layer: TextureLayer) => TextureBuilder;\n  render: () => Promise<HTMLCanvasElement | OffscreenCanvas>;\n  clear: () => TextureBuilder;\n};\n","import type { ICanvasRenderingContext } from \"@babylonjs/core/Engines/ICanvas\";\nimport type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\n\nexport const drawOnTexture = (\n  texture: DynamicTexture,\n  render: (\n    ctx: ICanvasRenderingContext,\n    size: { width: number; height: number }\n  ) => void\n) => {\n  const size = texture.getSize();\n  const ctx = texture.getContext();\n  render(ctx, size);\n  texture.update();\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { drawOnTexture } from \"./drawOnTexture\";\n\nexport const clearTexture = (texture: DynamicTexture) => {\n  drawOnTexture(texture, (ctx, size) => {\n    const { width, height } = size;\n    ctx.clearRect(0, 0, width, height);\n  });\n};\n","import { Textures } from \"./Textures\";\n\nexport const debugImage = (\n  image: HTMLCanvasElement | HTMLImageElement,\n  label = \"DEBUG IMAGE\"\n) => {\n  // const canvas = document.createElement(\"canvas\");\n  const canvas = Textures.copyToCanvas(image, 1024, 1024);\n  // canvas.style.position = \"absolute\";\n  // canvas.style.left = \"0\";\n  // canvas.style.top = \"0\";\n  canvas.style.border = \"1px solid grey\";\n  const labelElement = document.createElement(\"div\");\n  labelElement.textContent = label;\n\n  document.body.appendChild(labelElement);\n  document.body.appendChild(canvas);\n  return new Promise((resolve, reject) => {\n    const onclick = () => {\n      canvas.remove();\n      labelElement.remove();\n      resolve(undefined);\n    };\n    canvas.onclick = onclick;\n    labelElement.onclick = onclick;\n  });\n};\n","import type { Scene } from \"@babylonjs/core\";\n\nexport const destroyTexture = (scene: Scene, name: string) => {\n  const tex = scene.getTextureByName(name);\n  if (!tex) {\n    return;\n  }\n  tex.dispose();\n  scene.removeTexture(tex);\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { Colors } from \"@mjt-engine/color\";\nimport { drawOnTexture } from \"./drawOnTexture\";\n\nexport const drawBackgroundOnTexture = (\n  texture: DynamicTexture,\n  options: Partial<{\n    color: string;\n  }> = {}\n) => {\n  const { color = \"black\" } = options;\n  drawOnTexture(texture, (ctx, size) => {\n    const { width, height } = size;\n    ctx.fillStyle = Colors.from(color).toString();\n    ctx.fillRect(0, 0, width, height);\n  });\n};\n","import type { DynamicTexture } from \"@babylonjs/core/Materials/Textures/dynamicTexture\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const drawTextOnTexture = (\n  texture: DynamicTexture,\n  text: string,\n\n  options: Partial<{\n    color: string;\n    outline: boolean;\n    outlineColor: string;\n    backgroundColor: string;\n    text: string;\n    textureSize: number;\n    textScale: number;\n    rotation: Point3;\n    fontFamily: string;\n    fontStyle: string;\n  }> = {}\n) => {\n  const {\n    backgroundColor,\n    outline = true,\n    color = \"black\",\n    fontFamily = \"monospace\",\n    fontStyle = \"bold\",\n    outlineColor = Colors.builder({ color: \"white\" }).alpha(0.1).toString(),\n    textureSize = Math.min(texture.getSize().width, texture.getSize().height),\n  } = options;\n  texture.hasAlpha = true;\n  let fontSize = textureSize;\n  let font = `${fontStyle} ${fontSize}px ${fontFamily}`;\n  const ctx = texture.getContext();\n\n  ctx.font = font;\n  let measure = ctx.measureText(text);\n  fontSize = (textureSize / measure.width) * textureSize;\n  font = `${fontStyle} ${fontSize}px ${fontFamily}`;\n  ctx.font = font;\n  const textX = 0;\n  measure = ctx.measureText(text);\n  /** @ts-ignore */\n  const top = measure[\"fontBoundingBoxAscent\"] ?? 0;\n  const textY = textureSize - (textureSize - top) / 2;\n  ctx.lineWidth = fontSize / 2;\n\n  const bbox = {\n    x: 0,\n    y: textY - fontSize,\n    width: textureSize,\n    height: top * 2,\n  };\n  if (isDefined(backgroundColor)) {\n    ctx.fillStyle = Colors.from(backgroundColor).toString();\n    const { x, y, width, height } = bbox;\n    // ctx.fillRect(0, textY - fontSize, textureSize, top * 2);\n    ctx.fillRect(x, y, width, height);\n  }\n  if (outline) {\n    ctx.strokeStyle = outlineColor;\n    ctx.strokeText(text, textX, textY);\n  }\n  ctx.fillStyle = color;\n  ctx.fillText(text, textX, textY);\n\n  texture.hasAlpha = true;\n  texture.update();\n  return bbox;\n};\n","import { Texture } from \"@babylonjs/core\";\n\nexport const TEXTURE_SAMPLING_MODES = {\n  linearNearest: Texture.LINEAR_NEAREST,\n  nearestNearest: Texture.NEAREST_NEAREST,\n  linearLinear: Texture.LINEAR_LINEAR,\n  nearestLinear: Texture.NEAREST_LINEAR,\n};\n","import type { BaseTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getTexture = <T extends BaseTexture>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n) => {\n  const texture = scene.getTextureByName(name);\n  if (isDefined(texture)) {\n    return texture as T;\n  }\n  return producer();\n};\n","import type { BaseTexture } from \"@babylonjs/core\";\nimport { DynamicTexture } from \"@babylonjs/core\";\nimport { iff } from \"@mjt-engine/object\";\nimport type { AllTextureOptions } from \"./Textures\";\n\nexport const updateTexture = (\n  texture: BaseTexture,\n  options: AllTextureOptions\n) => {\n  const { hasAlpha } = options;\n  iff(hasAlpha, (value) => {\n    texture.hasAlpha = value;\n  });\n\n  if (texture instanceof DynamicTexture) {\n    texture.update();\n  }\n};\n","import { DynamicTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport type { DynamicTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getDynamicTexture = (\n  scene: Scene,\n  name: string,\n  options: DynamicTextureOptions = {}\n) => {\n  const texture = getTexture(scene, name, () => {\n    const {\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n      width = 1024,\n      height = 1024,\n      init,\n    } = options;\n    const result = new DynamicTexture(\n      name,\n      {\n        width,\n        height,\n      },\n      scene,\n      generateMipMaps,\n      TEXTURE_SAMPLING_MODES[samplingMode]\n    );\n    if (init) {\n      init(result.getContext());\n      result.update();\n    }\n    return result;\n  });\n  updateTexture(texture, options);\n  return texture;\n};\n","import { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport type { TextureSamplingModeMap } from \"./Textures\";\n\n\nexport const samplingModeNumber = (\n  name: keyof TextureSamplingModeMap\n): number => {\n  return TEXTURE_SAMPLING_MODES[name];\n};\n","import { HtmlElementTexture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { HtmlElementTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { samplingModeNumber } from \"./samplingModeNumber\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getHtmlElementTexture = (\n  scene: Scene,\n  name: string,\n  options: HtmlElementTextureOptions\n) => {\n  return getTexture(scene, name, () => {\n    const {\n      element,\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n    } = options;\n    if (!element) {\n      throw new Error(\"HTML element is required to create texture\", {\n        cause: options,\n      });\n    }\n    const texture = new HtmlElementTexture(name, element, {\n      generateMipMaps,\n      samplingMode: samplingModeNumber(samplingMode),\n      engine: scene.getEngine(),\n      scene,\n    });\n    updateTexture(texture, options);\n    return texture;\n  });\n};\n","import { Texture } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport type { PathTextureOptions } from \"./Textures\";\nimport { getTexture } from \"./getTexture\";\nimport { samplingModeNumber } from \"./samplingModeNumber\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport const getPathTexture = (\n  scene: Scene,\n  name: string,\n  options: PathTextureOptions\n) => {\n  const texture = getTexture(scene, name, () => {\n    const {\n      src,\n      generateMipMaps = true,\n      samplingMode = \"linearNearest\",\n    } = options;\n    if (!src) {\n      throw new Error(\"src is required\", { cause: options });\n    }\n    const texture = new Texture(src, scene, {\n      samplingMode: samplingModeNumber(samplingMode),\n    });\n    texture.name = name;\n    return texture;\n  });\n\n  updateTexture(texture, options);\n  return texture;\n};\n","import type { ICanvasRenderingContext } from \"@babylonjs/core\";\nimport type { TEXTURE_SAMPLING_MODES } from \"./TEXTURE_SAMPLING_MODES\";\nimport { builder } from \"./builder\";\nimport { clearTexture } from \"./clearTexture\";\nimport { copyToCanvas } from \"./copyToCanvas\";\nimport { debugImage } from \"./debugImage\";\nimport { destroyTexture } from \"./destroyTexture\";\nimport { drawBackgroundOnTexture } from \"./drawBackgroundOnTexture\";\nimport { drawOnTexture } from \"./drawOnTexture\";\nimport { drawTextOnTexture } from \"./drawTextOnTexture\";\nimport { getDynamicTexture } from \"./getDynamicTexture\";\nimport { getHtmlElementTexture } from \"./getHtmlElementTexture\";\nimport { getPathTexture } from \"./getPathTexture\";\nimport { getTexture } from \"./getTexture\";\nimport { imageToTexture } from \"./imageToTexture\";\nimport { updateTexture } from \"./updateTexture\";\n\nexport type TextureSamplingModeMap = typeof TEXTURE_SAMPLING_MODES;\n\nexport type TextureOptions = Partial<{\n  hasAlpha: boolean;\n  generateMipMaps: boolean;\n  samplingMode: keyof TextureSamplingModeMap;\n}>;\n\nexport type HtmlElementTextureOptions = Partial<\n  TextureOptions & {\n    element: HTMLCanvasElement | HTMLVideoElement;\n  }\n>;\n\nexport type PathTextureOptions = Partial<\n  TextureOptions & {\n    src: string;\n  }\n>;\n\nexport type DynamicTextureOptions = Partial<\n  TextureOptions & {\n    width: number;\n    height: number;\n    init: (ctx: ICanvasRenderingContext) => void;\n  }\n>;\n\nexport type AllTextureOptions = HtmlElementTextureOptions &\n  DynamicTextureOptions;\n\nexport const Textures = {\n  builder,\n  copyToCanvas,\n  debugImage,\n  getTexture,\n  getHtmlElementTexture,\n  getDynamicTexture,\n  getPathTexture,\n  updateTexture,\n\n  imageToTexture,\n\n  drawTextOnTexture,\n  drawOnTexture,\n  drawBackgroundOnTexture,\n  clearTexture,\n  destroyTexture,\n};\n","import {\n  GlowLayer,\n  type IGlowLayerOptions,\n} from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getGlowLayer = (\n  scene: Scene,\n  name: string,\n  options?: IGlowLayerOptions\n) => {\n  // workaround Bug in getGlowlayerbyName\n  const layerMaybe = scene?.effectLayers?.length\n    ? scene.getGlowLayerByName(name)\n    : undefined;\n  if (isDefined(layerMaybe)) {\n    return layerMaybe;\n  }\n  return new GlowLayer(name, scene, options);\n};\n","import type { IHighlightLayerOptions } from \"@babylonjs/core\";\nimport { HighlightLayer } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getHighlightLayer = <T extends HighlightLayer>(\n  scene: Scene,\n  name: string,\n  options?: IHighlightLayerOptions\n) => {\n  const layerMaybe = scene.getHighlightLayerByName(name);\n  if (isDefined(layerMaybe)) {\n    return layerMaybe;\n  }\n  return new HighlightLayer(name, scene, options);\n};\n","import { getGlowLayer } from \"./getGlowLayer\";\nimport { getHighlightLayer } from \"./getHighlightLayer\";\n\nexport const Layers = {\n  getGlowLayer,\n  getHighlightLayer,\n};\n","import { getMaterial } from \"./getMaterial\";\nimport type { MaterialTypeMap } from \"./MaterialTypeMap\";\nimport { updateMaterial } from \"./updateMaterial\";\nimport { updateStandardMaterial } from \"./updateStandardMaterial\";\n\nexport type MaterialOptions = Partial<{\n  type: keyof MaterialTypeMap;\n}>;\n\nexport type StandardMaterialOptions = Partial<\n  MaterialOptions & {\n    diffuseTexture: string;\n    emissiveTexture: string;\n    ambientTexture: string;\n    opacityTexture: string;\n    diffuseColor: string;\n    alpha: number;\n    specularColor: string;\n    ambientColor: string;\n    emissiveColor: string;\n  }\n>;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type PbrMaterialOptions = Partial<{}>;\nexport type AllMaterialOptions = StandardMaterialOptions & PbrMaterialOptions;\n\nexport const Materials = {\n  getMaterial,\n  updateMaterial,\n  updateStandardMaterial,\n};\n","import { TransformNode } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\n\nexport const getTransformNode = (scene: Scene, name: string): TransformNode => {\n  const node = scene.getTransformNodeByName(name);\n  if (isDefined(node)) {\n    return node;\n  }\n  return new TransformNode(name, scene);\n};\n","import { getTransformNode } from \"./getTransformNode\";\n\nexport const Nodes = {\n  getTransformNode,\n};\n","import { type Scene } from \"@babylonjs/core\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { BabScene } from \"../type/BabScene\";\nimport { BabParticleSystem } from \"../type/BabParticleSystem\";\n\nexport const getSolidParticleSystemsMetadata = (\n  scene: BabScene\n): Record<string, BabParticleSystem> => {\n  const metadata = scene.metadata ?? {};\n  const spsMetadata = metadata[\"solidParticleSystems\"] ?? {};\n\n  if (isDefined(spsMetadata)) {\n    return spsMetadata;\n  }\n  scene.metadata = {\n    ...metadata,\n    solidParticleSystems: {},\n  };\n\n  return spsMetadata;\n};\n\nexport const getParticleSystem = <T extends BabParticleSystem>(\n  scene: Scene,\n  name: string,\n  producer: () => T\n): T => {\n  const spsMetadata = getSolidParticleSystemsMetadata(scene);\n  const spsMaybe = spsMetadata[name];\n\n  if (isDefined(spsMaybe)) {\n    spsMaybe as T;\n  }\n  const result = producer();\n  spsMetadata[name] = result;\n  return result;\n};\n","import { SolidParticleSystem } from \"@babylonjs/core\";\nimport { BabScene } from \"../type/BabScene\";\nimport { getParticleSystem } from \"./getParticleSystem\";\n\nexport const getSolidParticleSystem = (\n  scene: BabScene,\n  name: string,\n  options: ConstructorParameters<typeof SolidParticleSystem>[2]\n): SolidParticleSystem => {\n  return getParticleSystem(scene, name, () => {\n    return new SolidParticleSystem(name, scene, {\n      ...options,\n    });\n  });\n};\n","import {\n  Mesh as BabMesh,\n  Scene as BabScene,\n  SolidParticle as BabSolidParticle,\n  SolidParticleSystem as BabSolidParticleSystem,\n  Color4,\n  SolidParticleSystem,\n  StandardMaterial,\n} from \"@babylonjs/core\";\nimport { Asserts } from \"@mjt-engine/assert\";\nimport { Materials } from \"../material/Materials\";\nimport { getSolidParticleSystem } from \"./getSolidParticleSystem\";\n\nexport type Sps = {\n  scene: BabScene;\n  getSystem: () => BabSolidParticleSystem;\n  dispose: () => void;\n  getInstance: () => BabSolidParticleSystem;\n  rebuild: () => void;\n  update: () => void;\n  addMesh: (mesh: BabMesh, count?: number) => void;\n  removeMesh: (mesh: BabMesh) => void;\n  syncParticlestoMeshes: () => void;\n  hasMesh: (meshName: string) => boolean;\n  updateParticlesByName: (\n    name: string,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  updateParticleByIndex: (\n    index: number,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  updateNextParticle: (\n    name: string,\n    fn: (particle: BabSolidParticle, index: number) => void\n  ) => void;\n  clearParticles: () => void;\n  getNames: () => Iterable<string>;\n};\n\nexport const Sps = (\n  scene: BabScene,\n  name: string,\n  options: Partial<{ material: string; onMeshBuild: (mesh: BabMesh) => void }> &\n    Parameters<typeof getSolidParticleSystem>[2] = {}\n): Sps => {\n  const nextIndexMap = new Map<string, number>();\n  const meshToCounts = new Map<BabMesh, number>();\n  const meshToParticleIndexes = new Map<BabMesh, number[]>();\n  const meshNameToParticleIndexes = new Map<string, number[]>();\n  const meshNameToMesh = new Map<string, BabMesh>();\n  const { material, onMeshBuild, ...rest } = options;\n\n  let system: BabSolidParticleSystem;\n\n  const renewSps = () => {\n    system?.mesh?.dispose(false);\n    system = new SolidParticleSystem(name, scene, {\n      ...rest,\n    });\n  };\n\n  renewSps();\n\n  const mod: Sps = {\n    scene,\n    clearParticles: () => {\n      system.particles.forEach((p, i) => {\n        p.color = TRANSPARENT_COLOR;\n      });\n      system.setParticles();\n      system.particles.forEach((p, i) => {\n        p.alive = false;\n      });\n    },\n    getSystem: () => {\n      return system;\n    },\n    getNames: () => {\n      return meshNameToParticleIndexes.keys();\n    },\n    hasMesh: (meshName: string) => {\n      return meshNameToParticleIndexes.has(meshName);\n    },\n    getInstance: () => {\n      return system;\n    },\n    updateNextParticle: (name, fn) => {\n      const indexesForName = Asserts.assertValue(\n        meshNameToParticleIndexes.get(name)\n      );\n      const nextIndexForName = Asserts.assertValue(nextIndexMap.get(name));\n      const nextIndex = indexesForName[nextIndexForName];\n      mod.updateParticleByIndex(nextIndex, fn);\n      nextIndexMap.set(name, nextIndexForName + 1);\n    },\n    updateParticleByIndex: (index, fn) => {\n      const particle = system.particles[index];\n      Asserts.assertValue(particle, `particle not found for ${index}`);\n      particle.alive = true;\n      fn(particle, index);\n    },\n    updateParticlesByName: (name, fn) => {\n      const indexes = meshNameToParticleIndexes.get(name);\n      if (indexes) {\n        indexes.forEach((index) => {\n          mod.updateParticleByIndex(index, fn);\n        });\n      }\n    },\n    removeMesh: (mesh: BabMesh) => {\n      meshToCounts.delete(mesh);\n      meshToParticleIndexes.delete(mesh);\n      meshNameToParticleIndexes.delete(mesh.name);\n      meshNameToMesh.delete(mesh.name);\n      mod.rebuild();\n    },\n    addMesh: (mesh: BabMesh, n = 1) => {\n      if (meshToCounts.has(mesh)) {\n        throw new Error(\n          `Mesh ${mesh.name} already exists in the Sps. Use removeMesh to remove it first.`\n        );\n      }\n      nextIndexMap.set(mesh.name, 0);\n      meshToCounts.set(mesh, n);\n      meshNameToMesh.set(mesh.name, mesh);\n      mod.rebuild();\n      mod.clearParticles();\n      mesh.setEnabled(false);\n    },\n    rebuild: () => {\n      renewSps();\n      meshToParticleIndexes.clear();\n      try {\n        meshToCounts.forEach((count, mesh) => {\n          system.addShape(mesh, count);\n          for (let i = 0; i < count; i++) {\n            const index = system.particles.length - 1 - i;\n\n            meshToParticleIndexes.set(mesh, [\n              ...(meshToParticleIndexes.get(mesh) || []),\n              index,\n            ]);\n            meshNameToParticleIndexes.set(mesh.name, [\n              ...(meshToParticleIndexes.get(mesh) || []),\n              index,\n            ]);\n          }\n        });\n        const mesh = system.buildMesh();\n        if (material) {\n          mesh.material = Materials.getMaterial(scene, material);\n        }\n        onMeshBuild?.(mesh);\n      } catch (e) {\n        console.error(e);\n      }\n    },\n    syncParticlestoMeshes: () => {\n      meshToParticleIndexes.forEach((indexes, mesh) => {\n        for (let i = 0; i < indexes.length; i++) {\n          const index = indexes[i];\n          const particle = Asserts.assertValue(system.particles[index]);\n          particle.position.copyFrom(mesh.position);\n          particle.rotation.copyFrom(mesh.rotation);\n          particle.scaling.copyFrom(mesh.scaling);\n          if (mesh.material instanceof StandardMaterial) {\n            const c3 = mesh.material.diffuseColor;\n            particle.color = new Color4(c3.r, c3.g, c3.b, mesh.material.alpha);\n          }\n        }\n      });\n    },\n    dispose: () => {\n      meshToCounts.clear();\n      meshToParticleIndexes.clear();\n      meshNameToParticleIndexes.clear();\n      meshNameToMesh.clear();\n      nextIndexMap.clear();\n      system?.mesh?.dispose();\n      system.dispose();\n    },\n    update: () => {\n      system.setParticles();\n      nextIndexMap.forEach((_, meshName) => {\n        nextIndexMap.set(meshName, 0);\n      });\n      system.particles.forEach((particle) => {\n        particle.alive = false;\n        particle.color = TRANSPARENT_COLOR;\n      });\n    },\n  };\n  return mod;\n};\n\nconst TRANSPARENT_COLOR = new Color4(0, 0, 0, 0);\n","import { getParticleSystem } from \"./getParticleSystem\";\nimport { getSolidParticleSystem } from \"./getSolidParticleSystem\";\nimport { Sps } from \"./Sps\";\nexport type { Sps } from \"./Sps\";\nexport const Particles = {\n  getSolidParticleSystem,\n  getParticleSystem,\n  Sps,\n};\n","import { Ray } from \"@babylonjs/core\";\nimport type { Point3 } from \"@mjt-engine/math\";\nimport { v3 } from \"../bab/v3\";\n\nexport const createRay = (\n  origin: Point3,\n  direction: Point3,\n  length?: number\n) => {\n  return new Ray(v3(origin), v3(direction), length);\n};\n","import type { Ray, TrianglePickingPredicate } from \"@babylonjs/core\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const pickWithRay = (\n  scene: Scene,\n  ray: Ray,\n  options: Partial<{\n    predicate: (mesh: AbstractMesh) => boolean;\n    fastCheck: boolean;\n    trianglePredicate: TrianglePickingPredicate;\n  }> = {}\n) => {\n  const {\n    trianglePredicate,\n    fastCheck,\n    predicate = (mesh: AbstractMesh) => mesh.isPickable,\n  } = options;\n  return scene.pickWithRay(ray, predicate, fastCheck, trianglePredicate);\n};\n","import { createRay } from \"./createRay\";\nimport { pickWithRay } from \"./pickWithRay\";\n\nexport const Rays = {\n  createRay,\n  pickWithRay,\n};\n","import type { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\nimport type { AbstractMesh } from \"@babylonjs/core\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\n\nexport const removeShadowFromMesh = (mesh: Mesh | AbstractMesh) => {\n  const scene = mesh.getScene();\n  mesh.dispose();\n  const shadowCasters = scene.getLightsByTags(\"shadowCaster\");\n  shadowCasters.forEach((caster) => {\n    const shadowGenerator = caster.metadata[\n      \"shadowGenerator\"\n    ] as ShadowGenerator;\n    shadowGenerator.removeShadowCaster(mesh);\n  });\n};\n","import type { ShadowGenerator } from \"@babylonjs/core/Lights/Shadows/shadowGenerator\";\nimport type { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\nimport type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\nimport { removeShadowFromMesh } from \"../mesh/removeShadowFromMesh\";\n\nexport const addShadowToMesh = (mesh: Mesh | InstancedMesh) => {\n  const scene = mesh.getScene();\n  const shadowCasters = scene.getLightsByTags(\"shadowCaster\");\n  shadowCasters.forEach((caster) => {\n    const shadowGenerator = caster.metadata[\n      \"shadowGenerator\"\n    ] as ShadowGenerator;\n    shadowGenerator.addShadowCaster(mesh);\n  });\n  return () => {\n    removeShadowFromMesh(mesh);\n  };\n};\n","import { addShadowToMesh } from \"./addShadowToMesh\";\n\nexport const Shadows = {\n  addShadowToMesh,\n};\n","import { Constants } from \"@babylonjs/core\";\nimport { GlowLayer, type IGlowLayerOptions } from \"@babylonjs/core\";\nimport { Color4 } from \"@babylonjs/core\";\nimport type { Scene } from \"@babylonjs/core\";\n\nexport const addGlowLayer = (\n  scene: Scene,\n  name: string,\n  options: Partial<IGlowLayerOptions> = {}\n) => {\n  const gl = new GlowLayer(name, scene, options);\n  gl.neutralColor = new Color4(0, 0, 0, 0);\n  return gl;\n};\n\nexport const Specials = {\n  addGlowLayer,\n  Constants,\n};\n","interface Frame {\n  frame: { x: number; y: number; w: number; h: number };\n}\n\ninterface AtlasJSON {\n  frames: Record<string, Frame>;\n}\n\ninterface BabylonSpriteMapFrame {\n  filename: string;\n  frame: { x: number; y: number; w: number; h: number };\n  rotated: boolean;\n  trimmed: boolean;\n  spriteSourceSize: { x: number; y: number; w: number; h: number };\n  sourceSize: { w: number; h: number };\n}\n\ninterface BabylonSpriteMapJSON {\n  frames: BabylonSpriteMapFrame[];\n}\n\nexport async function createTextureAtlas({\n  baseUrl,\n  imageNames,\n  atlasSize,\n  padding = 0,\n}: {\n  atlasSize: number;\n  baseUrl: string;\n  imageNames: string[];\n  padding?: number;\n}): Promise<{\n  canvas: HTMLCanvasElement;\n  atlasBlob: Blob;\n  spritePackageManagerJson: AtlasJSON;\n  babylonSpriteMapJson: BabylonSpriteMapJSON;\n}> {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = atlasSize;\n  canvas.height = atlasSize;\n  const ctx = canvas.getContext(\"2d\")!;\n\n  const simpleFrames: Record<string, Frame> = {};\n  const babylonFrames: BabylonSpriteMapFrame[] = [];\n\n  let x = 0;\n  let y = 0;\n  let rowHeight = 0;\n\n  for (const name of imageNames) {\n    const filename = name.endsWith(\".png\") ? name : `${name}.png`;\n    const img = await loadImage(`${baseUrl}/${filename}`);\n\n    const spriteWidth = img.width + padding * 2;\n    const spriteHeight = img.height + padding * 2;\n\n    if (x + spriteWidth > atlasSize) {\n      x = 0;\n      y += rowHeight;\n      rowHeight = 0;\n    }\n\n    if (y + spriteHeight > atlasSize) {\n      throw new Error(`Not enough space in atlas for image: ${filename}`);\n    }\n\n    ctx.drawImage(img, x + padding, y + padding);\n\n    simpleFrames[filename] = {\n      frame: {\n        x: x + padding,\n        y: y + padding,\n        w: img.width,\n        h: img.height,\n      },\n    };\n\n    babylonFrames.push({\n      filename,\n      frame: {\n        x: x + padding,\n        y: y + padding,\n        w: img.width,\n        h: img.height,\n      },\n      rotated: false,\n      trimmed: false,\n      spriteSourceSize: { x: 0, y: 0, w: img.width, h: img.height },\n      sourceSize: { w: img.width, h: img.height },\n    });\n\n    x += spriteWidth;\n    rowHeight = Math.max(rowHeight, spriteHeight);\n  }\n\n  const atlasBlob = await new Promise<Blob>((resolve) =>\n    canvas.toBlob((blob) => resolve(blob!), \"image/png\")\n  );\n\n  return {\n    canvas,\n    atlasBlob,\n    spritePackageManagerJson: { frames: simpleFrames },\n    babylonSpriteMapJson: { frames: babylonFrames },\n  };\n}\n\nasync function loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.src = src;\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(new Error(`Failed to load image: ${src}`));\n  });\n}\n","import {\n  type Scene,\n  SpriteManager,\n  SpriteManagerOptions,\n  SpriteMap,\n  SpritePackedManager,\n} from \"@babylonjs/core\";\nimport { isDefined, isUndefined } from \"@mjt-engine/object\";\nimport { BabSpriteManager } from \"../type/BabSpriteManager\";\n\nexport const getSpritePackedManager = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    capacity: number;\n    cellSize: { width: number; height: number } | number;\n    atlasUrl: string;\n    atlasBlob?: Blob;\n    epsilon?: number;\n    samplingMode?: number;\n    fromPacked?: boolean;\n    spriteJSON?: any | null;\n    options?: SpriteManagerOptions;\n  }> = {}\n): BabSpriteManager => {\n  const managerMaybe = scene?.spriteManagers?.find((sm) => sm.name === name);\n  if (isDefined(managerMaybe)) {\n    return managerMaybe as BabSpriteManager;\n  }\n  const {\n    capacity = 1,\n    atlasUrl,\n    atlasBlob,\n    epsilon,\n    samplingMode,\n    spriteJSON,\n    options: spriteManagerOptions,\n  } = options;\n  let objectUrl: string | undefined;\n  try {\n    if (atlasBlob) {\n      objectUrl = URL.createObjectURL(atlasBlob);\n    }\n    const realizedUrl = isDefined(atlasUrl) ? atlasUrl : objectUrl;\n    if (isUndefined(realizedUrl)) {\n      throw new Error(\"altasUrl or atlasBlob is required\", { cause: options });\n    }\n    return new SpritePackedManager(\n      name,\n      realizedUrl,\n      capacity,\n      scene,\n      spriteJSON,\n      epsilon,\n      samplingMode,\n      spriteManagerOptions\n    );\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n};\n\nexport const getSpriteManager = (\n  scene: Scene,\n  name: string,\n  options: Partial<{\n    capacity: number;\n    cellSize: { width: number; height: number } | number;\n    atlasUrl: string;\n    atlasBlob?: Blob;\n    epsilon?: number;\n    samplingMode?: number;\n    fromPacked?: boolean;\n    spriteJSON?: any | null;\n    options?: SpriteManagerOptions;\n  }> = {}\n): BabSpriteManager => {\n  const managerMaybe = scene?.spriteManagers?.find((sm) => sm.name === name);\n  if (isDefined(managerMaybe)) {\n    return managerMaybe as BabSpriteManager;\n  }\n  const {\n    capacity = 1,\n    cellSize = 64,\n    atlasUrl,\n    atlasBlob,\n    epsilon,\n    samplingMode,\n    fromPacked,\n    spriteJSON,\n    options: spriteManagerOptions,\n  } = options;\n  let objectUrl: string | undefined;\n  try {\n    if (atlasBlob) {\n      objectUrl = URL.createObjectURL(atlasBlob);\n    }\n    const realizedUrl = isDefined(atlasUrl) ? atlasUrl : objectUrl;\n    if (isUndefined(realizedUrl)) {\n      throw new Error(\"altasUrl or atlasBlob is required\", { cause: options });\n    }\n    return new SpriteManager(\n      name,\n      realizedUrl,\n      capacity,\n      cellSize,\n      scene,\n      epsilon,\n      samplingMode,\n      fromPacked,\n      spriteJSON,\n      spriteManagerOptions\n    );\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n};\n","import { type Scene, Sprite } from \"@babylonjs/core\";\nimport { assertValue } from \"@mjt-engine/assert\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { getSpriteManager } from \"./getSpriteManager\";\n\nexport const getSprite = (\n  scene: Scene,\n  name: string,\n  spriteManagerName: string\n): Sprite => {\n  const spriteManager = assertValue(getSpriteManager(scene, spriteManagerName));\n  const spriteMaybe = spriteManager?.sprites?.find((s) => s.name === name);\n  if (isDefined(spriteMaybe)) {\n    return spriteMaybe;\n  }\n  return new Sprite(name, spriteManager);\n};\n","import { createTextureAtlas } from \"./createTextureAtlas\";\nimport { getSprite } from \"./getSprite\";\nimport { getSpriteManager, getSpritePackedManager } from \"./getSpriteManager\";\n\nexport const Sprites = {\n  getSpriteManager,\n  getSprite,\n  createTextureAtlas,\n  getSpritePackedManager,\n};\n","import { Curve3 } from \"@babylonjs/core\";\nimport type { Vector3 } from \"@babylonjs/core\";\nimport type { SolidParticle } from \"@babylonjs/core\";\nimport { Maths, toVec3 } from \"@mjt-engine/math\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { Randoms, type NextRandom } from \"@mjt-engine/random\";\nimport { v3 } from \"../bab/v3\";\n\nexport const animateExplosion = (\n  particle: SolidParticle,\n\n  options: Partial<{\n    random: NextRandom;\n    radius: number;\n    maxBounce: number;\n    groundZ: number;\n    speed: number;\n    decay: number;\n    dispose: () => void;\n  }> = {}\n) => {\n  const {\n    random = Randoms.globalRandom,\n    radius = 1,\n    maxBounce = 0,\n    groundZ = 0,\n    speed = 20,\n    decay = 0.01,\n    dispose = () => (particle.isVisible = false),\n  } = options;\n\n  // const random = Noises.noiseStream(seed);\n  // use path\n  {\n    const path = particle.props?.[\"path\"] as Vector3[];\n    if (isDefined(path) && path.length > 0) {\n      const next = path.pop();\n      if (!next) {\n        throw new Error(\"No next value from path\", { cause: path });\n      }\n      // console.log(`next: ${next.x} ${next.y} ${next.z}`);\n      particle.position = next;\n      return;\n    }\n  }\n\n  // setup path\n  {\n    const { bounces = maxBounce } = particle.props ?? {};\n    if (bounces <= 0) {\n      if (random() < decay) {\n        dispose();\n      }\n      return;\n    }\n    const bounceEnergy = bounces / maxBounce;\n    const start = particle.position;\n    const [x, y, z] = toVec3(start);\n\n    const rg = (x: number) => {\n      return (random() * radius * 2 - radius) * (bounceEnergy / 4) + x;\n    };\n\n    // ground position\n    const [gx, gy] = [rg(x), rg(y)];\n\n    const end = v3([gx, gy, groundZ]);\n\n    const [mx, my, mz] = toVec3(Maths.midPoint3(start, end));\n    const mid1 = v3(mx, my, z - random() * bounceEnergy * 3);\n    // const mid2 = v3(x, y, mz - random() * bounceEnergy * 3);\n\n    const catRom = Curve3.CreateCatmullRomSpline([start, mid1, end], speed);\n    const path = catRom.getPoints().reverse();\n\n    // const rotationAxis = v3([0, 1, 0]);\n    // const rotationAmount = 2 * random() - 1;\n    // mesh.rotate(v3(rotationAxis), rotationAmount);\n    // console.log(`mb ${maxBounce}, bounces: ${bounces} ${Date.now()}`);\n    const pathMetadata = {\n      path,\n      bounces: bounces - 1,\n      // rotationAxis: [2 * random() - 1, 2 * random() - 1, 2 * random() - 1],\n    };\n    const metadata = particle.props ?? {};\n    particle.props = { ...metadata, ...pathMetadata };\n  }\n};\n","/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nexport class AndOrNotEvaluator {\n    /**\n     * Evaluate a query\n     * @param query defines the query to evaluate\n     * @param evaluateCallback defines the callback used to filter result\n     * @returns true if the query matches\n     */\n    static Eval(query, evaluateCallback) {\n        if (!query.match(/\\([^()]*\\)/g)) {\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n        }\n        else {\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\n                // remove parenthesis\n                r = r.slice(1, r.length - 1);\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n            });\n        }\n        if (query === \"true\") {\n            return true;\n        }\n        if (query === \"false\") {\n            return false;\n        }\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\n    }\n    static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {\n        evaluateCallback =\n            evaluateCallback ||\n                ((r) => {\n                    return r === \"true\" ? true : false;\n                });\n        let result;\n        const or = parenthesisContent.split(\"||\");\n        for (const i in or) {\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n                const and = ori.split(\"&&\");\n                if (and.length > 1) {\n                    for (let j = 0; j < and.length; ++j) {\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n                        if (andj !== \"true\" && andj !== \"false\") {\n                            if (andj[0] === \"!\") {\n                                result = !evaluateCallback(andj.substring(1));\n                            }\n                            else {\n                                result = evaluateCallback(andj);\n                            }\n                        }\n                        else {\n                            result = andj === \"true\" ? true : false;\n                        }\n                        if (!result) {\n                            // no need to continue since 'false && ... && ...' will always return false\n                            ori = \"false\";\n                            break;\n                        }\n                    }\n                }\n                if (result || ori === \"true\") {\n                    // no need to continue since 'true || ... || ...' will always return true\n                    result = true;\n                    break;\n                }\n                // result equals false (or undefined)\n                if (ori !== \"true\" && ori !== \"false\") {\n                    if (ori[0] === \"!\") {\n                        result = !evaluateCallback(ori.substring(1));\n                    }\n                    else {\n                        result = evaluateCallback(ori);\n                    }\n                }\n                else {\n                    result = ori === \"true\" ? true : false;\n                }\n            }\n        }\n        // the whole parenthesis scope is replaced by 'true' or 'false'\n        return result ? \"true\" : \"false\";\n    }\n    static _SimplifyNegation(booleanString) {\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\n            // remove whitespaces\n            r = r.replace(/[\\s]/g, () => \"\");\n            return r.length % 2 ? \"!\" : \"\";\n        });\n        booleanString = booleanString.trim();\n        if (booleanString === \"!true\") {\n            booleanString = \"false\";\n        }\n        else if (booleanString === \"!false\") {\n            booleanString = \"true\";\n        }\n        return booleanString;\n    }\n}\n//# sourceMappingURL=andOrNotEvaluator.js.map","import { AndOrNotEvaluator } from \"./andOrNotEvaluator.js\";\n/**\n * Class used to store custom tags\n */\nexport class Tags {\n    /**\n     * Adds support for tags on the given object\n     * @param obj defines the object to use\n     */\n    static EnableFor(obj) {\n        obj._tags = obj._tags || {};\n        obj.hasTags = () => {\n            return Tags.HasTags(obj);\n        };\n        obj.addTags = (tagsString) => {\n            return Tags.AddTagsTo(obj, tagsString);\n        };\n        obj.removeTags = (tagsString) => {\n            return Tags.RemoveTagsFrom(obj, tagsString);\n        };\n        obj.matchesTagsQuery = (tagsQuery) => {\n            return Tags.MatchesQuery(obj, tagsQuery);\n        };\n    }\n    /**\n     * Removes tags support\n     * @param obj defines the object to use\n     */\n    static DisableFor(obj) {\n        delete obj._tags;\n        delete obj.hasTags;\n        delete obj.addTags;\n        delete obj.removeTags;\n        delete obj.matchesTagsQuery;\n    }\n    /**\n     * Gets a boolean indicating if the given object has tags\n     * @param obj defines the object to use\n     * @returns a boolean\n     */\n    static HasTags(obj) {\n        if (!obj._tags) {\n            return false;\n        }\n        const tags = obj._tags;\n        for (const i in tags) {\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Gets the tags available on a given object\n     * @param obj defines the object to use\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\n     * @returns the tags\n     */\n    static GetTags(obj, asString = true) {\n        if (!obj._tags) {\n            return null;\n        }\n        if (asString) {\n            const tagsArray = [];\n            for (const tag in obj._tags) {\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\n                    tagsArray.push(tag);\n                }\n            }\n            return tagsArray.join(\" \");\n        }\n        else {\n            return obj._tags;\n        }\n    }\n    /**\n     * Adds tags to an object\n     * @param obj defines the object to use\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\n     */\n    static AddTagsTo(obj, tagsString) {\n        if (!tagsString) {\n            return;\n        }\n        if (typeof tagsString !== \"string\") {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        for (const tag of tags) {\n            Tags._AddTagTo(obj, tag);\n        }\n    }\n    /**\n     * @internal\n     */\n    static _AddTagTo(obj, tag) {\n        tag = tag.trim();\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\n            return;\n        }\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\n            return;\n        }\n        Tags.EnableFor(obj);\n        obj._tags[tag] = true;\n    }\n    /**\n     * Removes specific tags from a specific object\n     * @param obj defines the object to use\n     * @param tagsString defines the tags to remove\n     */\n    static RemoveTagsFrom(obj, tagsString) {\n        if (!Tags.HasTags(obj)) {\n            return;\n        }\n        const tags = tagsString.split(\" \");\n        for (const t in tags) {\n            Tags._RemoveTagFrom(obj, tags[t]);\n        }\n    }\n    /**\n     * @internal\n     */\n    static _RemoveTagFrom(obj, tag) {\n        delete obj._tags[tag];\n    }\n    /**\n     * Defines if tags hosted on an object match a given query\n     * @param obj defines the object to use\n     * @param tagsQuery defines the tag query\n     * @returns a boolean\n     */\n    static MatchesQuery(obj, tagsQuery) {\n        if (tagsQuery === undefined) {\n            return true;\n        }\n        if (tagsQuery === \"\") {\n            return Tags.HasTags(obj);\n        }\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\n    }\n}\n//# sourceMappingURL=tags.js.map","import { Mesh } from \"@babylonjs/core\";\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { v3 } from \"../bab/v3\";\nimport { getBoxInstance } from \"../mesh/getBoxInstance\";\n\nexport const voxDataToComplexModel = (\n  scene: Scene,\n  voxData: VoxData,\n  name: string\n) => {\n  const { XYZI, RGBA } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n  const parent = new Mesh(name, scene);\n  // const centeringNode = new Mesh(`centering-${name}`);\n  const meshes = XYZI.map((xyzi, index) => {\n    const color = colors[xyzi.i];\n    const mesh = getBoxInstance(scene, `voxel-${color}`, {\n      color,\n      material: `voxel-material-${color}`,\n    });\n    mesh.position = v3(xyzi);\n    // mesh.parent = centeringNode;\n    mesh.parent = parent;\n\n    return mesh;\n  });\n  Tags.AddTagsTo(parent, \"complex\");\n  return parent;\n};\n","\nexport const toOrderedString = (obj: object) => {\n  const sorted = Object.entries(obj).sort((a, b) => {\n    const [keyA] = a;\n    const [keyB] = b;\n    return keyA.localeCompare(keyB);\n  });\n  return JSON.stringify(sorted);\n};\n","import type { Mesh } from \"@babylonjs/core/Meshes/mesh\";\n\nexport const groupMeshesByMaterial = (meshes: Mesh[]) => {\n  const result: Record<string, Mesh[]> = {};\n\n  meshes.forEach((mesh) => {\n    const materialName = mesh?.material?.name;\n    if (!materialName) {\n      throw new Error(\"Mesh material is missing name\", { cause: mesh });\n    }\n    const meshes = result[materialName] ?? [];\n    meshes.push(mesh);\n    result[materialName] = meshes;\n  });\n  return result;\n};\n","import { Mesh } from \"@babylonjs/core\";\nimport { Tags } from \"@babylonjs/core/Misc/tags\";\nimport type { Scene } from \"@babylonjs/core\";\nimport { Colors } from \"@mjt-engine/color\";\nimport type { VoxData } from \"@mjt-engine/magica-voxels\";\nimport { toVec3 } from \"@mjt-engine/math\";\nimport { Arrays, isDefined } from \"@mjt-engine/object\";\nimport { getMaterial } from \"../material/getMaterial\";\nimport { getBox } from \"../mesh/getBox\";\nimport { mergeMeshes } from \"../mesh/mergeMeshes\";\nimport { toOrderedString } from \"../util/toOrderedString\";\nimport { groupMeshesByMaterial } from \"./groupMeshesByMaterial\";\n\nexport const voxDataToMergedModel = (\n  scene: Scene,\n  voxData: VoxData,\n  name: string\n) => {\n  const { XYZI, RGBA } = voxData;\n\n  const colors = RGBA.map((rgba) => {\n    const { r, g, b, a } = rgba;\n    return Colors.builder({ color: [r, g, b, a], model: \"rgba\" }).toString();\n  });\n  // console.log(`${name} voxels: ${XYZI.length} colors: ${colors.length}`);\n  // const parent = new Mesh(name, scene);\n  // const centeringNode = new Mesh(`centering-${name}`);\n  const voxels = XYZI.map((xyzi, index) => {\n    const color = colors[xyzi.i];\n\n    const [x, y, z] = toVec3(xyzi);\n    const mesh = getBox(\n      scene,\n      `voxel-merged-${color}-${toOrderedString(xyzi)}`,\n      {\n        position: [x, y, z],\n        // color,\n        // material: `voxel-merged-material-${color}`,\n        material: \"voxel-material\",\n        colors: Arrays.from(6).map(() => color),\n      }\n    );\n    mesh.setEnabled(false);\n    return mesh;\n  });\n  const grouped = groupMeshesByMaterial(voxels);\n  const subMerged = Object.values(grouped).map((group) => mergeMeshes(group));\n\n  const merged = new Mesh(`merged-${name}`, scene);\n  subMerged.filter(isDefined).forEach((m) => (m.parent = merged));\n\n  const material = getMaterial(scene, \"voxel-material\", \"standard\");\n\n  subMerged.filter(isDefined).forEach((m) => (m.material = material));\n\n  // voxels.forEach((v) => v.setParent(merged));\n  merged.metadata = {\n    voxels: voxels,\n  };\n\n  // const merged = mergeMeshes(meshes, {\n  //   // multiMultiMaterials: true,\n  //   disposeSource: true,\n  // });\n  // merged.name = name;\n  // merged.refreshBoundingInfo();\n  // const center = merged.getBoundingInfo().boundingBox.center;\n  // merged.dispose();\n  // centeringNode.position = centeringNode.position.subtract(center);\n  // centeringNode.parent = parent;\n  // return parent;\n  Tags.AddTagsTo(merged, \"merged\");\n  // const model = new TransformNode(name);\n  const model = new Mesh(name, scene);\n  model.metadata = {\n    voxels: voxels,\n  };\n  merged.parent = model;\n\n  // merged.refreshBoundingInfo();\n  // const mergedCenter = merged.getBoundingInfo().boundingSphere.center;\n  // merged.position = v3(0,0,-30);\n  return model;\n};\n","import { animateExplosion } from \"./animateExplosion\";\nimport { voxDataToComplexModel } from \"./voxDataToComplexModel\";\nimport { voxDataToMergedModel } from \"./voxDataToMergedModel\";\nimport { voxDataToSps } from \"./voxDataToSps\";\n\nexport const Voxels = {\n  animateExplosion,\n  voxDataToSps,\n  voxDataToMergedModel,\n  voxDataToComplexModel,\n};\n","import * as BABYLON from \"@babylonjs/core\";\nimport { Scene as BabScene } from \"@babylonjs/core\";\nimport { BabWebXRSessionManager } from \"../camera/Cameras\";\n\n\nexport const createWebXrSessionManager = (\n  scene: BabScene\n): BabWebXRSessionManager => {\n  return new BABYLON.WebXRSessionManager(scene);\n};\n","import { createDefaultEnvironment } from \"./createDefaultHelper\";\nimport { createWebXrExperience } from \"./createWebXrExperience\";\nimport { createWebXrSessionManager } from \"./createWebXrSessionManager\";\nimport { helloXrWorld } from \"./hellowXrWorld\";\n\nexport const Wxrs = {\n  createWebXrSessionManager,\n  helloXrWorld,\n  createDefaultEnvironment,\n  createWebXrExperience,\n};\n","import * as BABYLON from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\n\nexport const spsDebug = ({\n  engine,\n  canvas,\n}: {\n  engine: BabEngine;\n  canvas: HTMLCanvasElement;\n}) => {\n  const scene = new BABYLON.Scene(engine);\n  console.log(scene);\n\n  const camera = new BABYLON.ArcRotateCamera(\n    \"ArcRotateCamera\",\n    -Math.PI / 2,\n    Math.PI / 2.2,\n    50,\n    new BABYLON.Vector3(0, 0, 0),\n    scene\n  );\n  camera.attachControl(canvas, true);\n  const light = new BABYLON.HemisphericLight(\n    \"light\",\n    new BABYLON.Vector3(0, 1, -1),\n    scene\n  );\n  const mat1 = new BABYLON.StandardMaterial(\"mat\");\n  mat1.diffuseTexture = new BABYLON.Texture(\"textures/earth.jpg\");\n  const mat2 = new BABYLON.StandardMaterial(\"mat\");\n  const fire = new BABYLON.Texture(\"textures/fire.jpg\");\n  mat2.diffuseTexture = fire;\n  const SPS = new BABYLON.SolidParticleSystem(\"SPS\", scene, {\n    useModelMaterial: true,\n  });\n  const box1 = BABYLON.MeshBuilder.CreateBox(\"FOO\");\n  // const poly = BABYLON.MeshBuilder.CreatePolyhedron(\"p\", { type: 2 });\n  box1.material = mat1;\n  // scene.addMesh(poly)\n  SPS.addShape(box1, 10_000); // 20 spheres\n  // SPS.addShape(box2, 20); // 20 spheres\n  // SPS.addShape(poly, 120); // 120 polyhedrons\n  // SPS.addShape(sphere, 80); // 80 other spheres\n  // sphere.dispose(); //dispose of original model sphere\n  // poly.dispose(); //dispose of original model poly\n\n  const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh\n\n  // initiate particles function\n  SPS.initParticles = () => {\n    for (let p = 0; p < SPS.nbParticles; p++) {\n      const particle = SPS.particles[p];\n      particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n      particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n      particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n    }\n  };\n\n  //Update SPS mesh\n  SPS.initParticles();\n  SPS.setParticles();\n  const update = () => {\n    const a = Math.sin(Date.now() * 0.005);\n\n    // mat.alpha=a\n    // box1.rotation.x = a\n    // box.rotate(new BABYLON. Vector3(0,1,0), new BABYLON.Vector3(0.1,0.1, 0.1), BABYLON.Space.WORLD);\n    // box.useVertexColors\n    // console.log(\"render\");\n    SPS.particles.forEach((p, i) => {\n      // console.log(p.name)\n      if (i > 20) {\n        p.rotation.x = a;\n        mat1.alpha = a;\n        mat1.diffuseTexture = fire;\n      } else {\n        p.rotation.y = a;\n      }\n    });\n    SPS.setParticles();\n  };\n\n  // mesh.material = mat;\n  // scene.registerBeforeRender(() => {});\n\n  return { scene, update };\n};\n\n\n","import * as BABYLON from \"@babylonjs/core\";\nimport { BabEngine } from \"../type/BabEngine\";\nimport { Cameras } from \"../camera/Cameras\";\nimport { Lights } from \"../light/Lights\";\nimport { Textures } from \"../texture/Textures\";\nimport { Meshes } from \"../mesh/Meshes\";\nimport { Particles } from \"../particle/Particles\";\nimport { Materials } from \"../material/Materials\";\nimport { Noises } from \"@mjt-engine/noise\";\nimport { Colors } from \"@mjt-engine/color\";\n\nexport const spsDebug2 = ({\n  engine,\n  canvas,\n}: {\n  engine: BabEngine;\n  canvas: HTMLCanvasElement;\n}) => {\n  const scene = new BABYLON.Scene(engine);\n  console.log(scene);\n\n  const camera = Cameras.getArcRotateCamera(scene, \"ArcRotateCamera\", {\n    alpha: -Math.PI / 2,\n    beta: Math.PI / 2.2,\n    radius: 50,\n    target: [0, 0, 0],\n  });\n  camera.attachControl(canvas, true);\n  const light = Lights.getHemisphericLight(scene, \"light\", {\n    direction: [0, 1, -1],\n  });\n  const tex = Textures.getPathTexture(scene, \"tex\", {\n    src: \"/images/test.jpg\",\n  });\n  const mat = Materials.getMaterial(scene, \"mat\", {\n    opacityTexture: tex.name,\n    // diffuseColor: Colors.from(\"red\").alpha(0.99).toString(),\n\n    // alpha: 0.99,\n  });\n  // mat.needAlphaBlending = () => true;\n  // mat.alphaMode = BABYLON.Constants.ALPHA_COMBINE;\n  // mat.\n  // const box1 = BABYLON.MeshBuilder.CreateBox(\"box1\", {\n  //   ma: mat.name,\n  // });\n  // const SPS = new BABYLON.SolidParticleSystem(\"SPS\", scene);\n  const box1 = Meshes.getBox(\n    scene,\n    \"box1\"\n    //  { material: mat.name }\n  );\n  // const poly = BABYLON.MeshBuilder.CreatePolyhedron(\"p\", { type: 2 });\n  // box1.material = mat1;\n  // scene.addMesh(poly)\n\n  const sps = Particles.Sps(scene, \"sps\", {\n    material: mat.name,\n    updatable: true,\n    // enableDepthSort: true,\n\n    onMeshBuild: (mesh) => {\n      mesh.useVertexColors = true;\n      mesh.hasVertexAlpha = true;\n      // mesh.material = mat;\n    },\n  });\n  sps.addMesh(box1, 10_000); // 20 spheres\n  sps.updateParticlesByName(\"box1\", (particle, i) => {\n    particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n    particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n    particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n  });\n\n  // SPS.addShape(box1, 10000); // 20 spheres\n\n  // const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh\n\n  // // initiate particles function\n  // SPS.initParticles = () => {\n  //   for (let p = 0; p < SPS.nbParticles; p++) {\n  //     const particle = SPS.particles[p];\n  //     particle.position.x = BABYLON.Scalar.RandomRange(-20, 20);\n  //     particle.position.y = BABYLON.Scalar.RandomRange(-20, 20);\n  //     particle.position.z = BABYLON.Scalar.RandomRange(-20, 20);\n  //   }\n  // };\n\n  // //Update SPS mesh\n  // SPS.initParticles();\n  // SPS.setParticles();\n  // sps.getInstance().mesh.useVertexColors = true;\n  const update = () => {\n    const s = Math.sin(Date.now() * 0.005);\n\n    const n = Noises.noiseStream(0);\n    // const n = () => 0.5;\n    sps.updateParticlesByName(\"box1\", (p, i) => {\n      p.color = new BABYLON.Color4(n(), n(), n(), 0.5);\n      if (Math.random() > 0.5) {\n        p.rotation.x = n() * s;\n      } else {\n        p.rotation.y = n() * s;\n      }\n    });\n    sps.update();\n\n    // SPS.particles.forEach((p, i) => {\n    //   // console.log(p.name)\n    //   if (i > 20) {\n    //     p.rotation.x = a;\n    //     // mat1.alpha = a;\n    //     // mat1.diffuseTexture = fire;\n    //   } else {\n    //     p.rotation.y = a;\n    //   }\n    // });\n    // SPS.setParticles();\n  };\n\n  return { scene, update };\n};\n","import { spsDebug } from \"./spsDebug\";\nimport { spsDebug2 } from \"./spsDebug2\";\n\nexport const Debugs = {\n  spsDebug,\n  spsDebug2,\n};\n"],"names":["v3","xOrPosition","y","z","Vector3","xx","yy","zz","toVec3","updateArcRotateCameraPosition","camera","position","currentAlpha","currentBeta","currentRadius","attachArcRotateCameraControls","options","keySensitivity","mouseSensitivity","parent","action","defaultAlpha","defaultBeta","defaultRadius","update","x","keyAnim","Inputs","MOUSE_STATE","event","auxDownLast","diff","Maths","toVec2","mouseAnim","delta","createCanvas","width","height","canvas","createWebGlEngine","optionsOrCanvas","antialias","xrCompatible","engine","Engine","pickMesh","scene","predicate","ray","Matrix","walkMeshes","mesh","walker","Scene","m","attachUniversalCameraControls","e","isDefined","isUndefined","createTopDownCamera","name","unitsTall","unitsWide","cameraLevel","disposeActive","UniversalCamera","Camera","getCamera","producer","updateCamera","alpha","beta","radius","target","rotation","minZ","maxZ","mode","orthoTop","orthoBottom","orthoLeft","orthoRight","iff","value","CAMERA_MODES","TargetCamera","ArcRotateCamera","getArcRotateCamera","getUniversalCamera","createDebugCamera","getFreeCamera","FreeCamera","Babs","getWebXrCamera","xrSessionManager","WebXRCamera","Cameras","getLight","light","updateLight","intensity","direction","HemisphericLight","PointLight","getHemisphericLight","getPointLight","Lights","c4","color","c","Colors","result","Color4","getMesh","updatable","meshMaybe","c3","hex","Color3","updateStandardMaterial","material","diffuseTexture","emissiveTexture","ambientTexture","opacityTexture","diffuseColor","specularColor","ambientColor","emissiveColor","texture","colorAlpha","updateMaterial","StandardMaterial","getMaterial","type","PBRMaterial","updateMesh","receiveShadows","Mesh","p","getBox","depth","colors","MeshBuilder","getBoxInstance","rootName","rootMesh","getSphere","calcTopOfMeshWorldPosition","BabPolyMap","getPolyhedron","size","calcClientRectForMesh","meshVectors","worldMatrix","transformMatrix","viewport","coordinates","v","proj","minX","maxX","extent","minY","maxY","destroyMesh","recurse","disposeMaterials","disposeTextures","findClosestPick","picks","a","b","getCylinder","arc","tag","getLine","instance","buildLineMesh","points","useVertexAlpha","pointColors","_","index","fleshedPoints","getMeshAsync","getMeshInstance","Asserts","getMeshInstanceAsync","getPlane","doubleSided","billboard","getTorusKnot","voxDataToCorrectedPoints","voxData","XYZI","SIZE","scale","xVoxelCenterCorrection","yVoxelCenterCorrection","zVoxelCenterCorrection","xyzi","tuple2","tuple3","voxDataToSps","RGBA","rgba","r","g","sps","SolidParticleSystem","box","pc","point","colorIndex","particle","getVoxModel","src","metadata","voxes","isInstancedMesh","InstancedMesh","lookAt","from","to","mergeMeshes","meshes","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","pickMeshes","describeMesh","search","padding","entry","key","Texture","Meshes","createScene","stopwatch","label","checkpoint","timeP","expr","renderOnce","sw","resolve","reject","reason","toggleInspector","Scenes","createDefaultEnvironment","env","createWebXrExperience","helloXrWorld","xr","helloWorld","STATE","ev","createWebGpuEngine","rest","WebGPUEngine","isWebGpuCapable","Engines","fixEyelashes","HIDE","GLOSS","fixEyes","textures","h","fixBumpMaps","fixDazFigure","loadDazFigure","props","path","SceneLoader","loadedScene","anim","progress","message","Models","copyToCanvas","image","copy","imageSrcToUrl","cvs","Images","imageToTexture","DynamicTexture","url","layerToPlane","layer","id","Randoms","plane","imageLayersToScene","layers","builder","drawOnTexture","render","ctx","clearTexture","debugImage","Textures","labelElement","onclick","destroyTexture","tex","drawBackgroundOnTexture","drawTextOnTexture","text","backgroundColor","outline","fontFamily","fontStyle","outlineColor","textureSize","fontSize","font","measure","textX","top","textY","bbox","TEXTURE_SAMPLING_MODES","getTexture","updateTexture","hasAlpha","getDynamicTexture","generateMipMaps","samplingMode","init","samplingModeNumber","getHtmlElementTexture","element","HtmlElementTexture","getPathTexture","getGlowLayer","layerMaybe","GlowLayer","getHighlightLayer","HighlightLayer","Layers","Materials","getTransformNode","node","TransformNode","Nodes","getSolidParticleSystemsMetadata","spsMetadata","getParticleSystem","spsMaybe","getSolidParticleSystem","Sps","nextIndexMap","meshToCounts","meshToParticleIndexes","meshNameToParticleIndexes","meshNameToMesh","onMeshBuild","system","renewSps","mod","i","TRANSPARENT_COLOR","meshName","fn","indexesForName","nextIndexForName","nextIndex","indexes","n","count","Particles","createRay","origin","length","Ray","pickWithRay","trianglePredicate","fastCheck","Rays","removeShadowFromMesh","caster","addShadowToMesh","Shadows","addGlowLayer","gl","Specials","Constants","createTextureAtlas","baseUrl","imageNames","atlasSize","simpleFrames","babylonFrames","rowHeight","filename","img","loadImage","spriteWidth","spriteHeight","atlasBlob","blob","getSpritePackedManager","managerMaybe","sm","capacity","atlasUrl","epsilon","spriteJSON","spriteManagerOptions","objectUrl","realizedUrl","SpritePackedManager","getSpriteManager","cellSize","fromPacked","SpriteManager","getSprite","spriteManagerName","spriteManager","assertValue","spriteMaybe","s","Sprite","Sprites","animateExplosion","random","maxBounce","groundZ","speed","decay","dispose","next","bounces","bounceEnergy","start","rg","gx","gy","end","mx","my","mz","mid1","pathMetadata","Curve3","AndOrNotEvaluator","query","evaluateCallback","parenthesisContent","or","ori","and","j","andj","booleanString","Tags","obj","tagsString","tagsQuery","tags","asString","tagsArray","t","voxDataToComplexModel","toOrderedString","sorted","keyA","keyB","groupMeshesByMaterial","materialName","voxDataToMergedModel","voxels","Arrays","grouped","subMerged","group","merged","model","Voxels","createWebXrSessionManager","BABYLON","Wxrs","spsDebug","mat1","mat2","fire","SPS","box1","spsDebug2","mat","Noises","Debugs"],"mappings":"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","x_google_ignoreList":[116,117]}