{"version":3,"file":"testVoxels.js","sourceRoot":"","sources":["../../src/voxel/testVoxels.ts"],"names":[],"mappings":";AAAA,kDAAkD;AAClD,4DAA4D;AAC5D,8CAA8C;AAC9C,yDAAyD;AACzD,mEAAmE;AAEnE,0CAA0C;AAC1C,wEAAwE;AACxE,yEAAyE;AACzE,yEAAyE;AACzE,sEAAsE;AAEtE,2CAA2C;AAC3C,gCAAgC;AAChC,4CAA4C;AAC5C,qDAAqD;AACrD,sCAAsC;AACtC,wCAAwC;AACxC,uCAAuC;AACvC,oDAAoD;AACpD,8BAA8B;AAE9B,wCAAwC;AACxC,6CAA6C;AAC7C,qDAAqD;AACrD,6BAA6B;AAC7B,QAAQ;AAER,2DAA2D;AAC3D,oCAAoC;AACpC,WAAW;AACX,kEAAkE;AAClE,6DAA6D;AAC7D,+DAA+D;AAC/D,qCAAqC;AACrC,yCAAyC;AACzC,uDAAuD;AACvD,mDAAmD;AACnD,+BAA+B;AAC/B,gCAAgC;AAChC,6CAA6C;AAC7C,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB,2BAA2B;AAC3B,yBAAyB;AACzB,QAAQ;AACR,wCAAwC;AACxC,mBAAmB;AACnB,mDAAmD;AACnD,mBAAmB;AACnB,sBAAsB;AACtB,0BAA0B;AAC1B,0BAA0B;AAC1B,wBAAwB;AACxB,2BAA2B;AAC3B,yDAAyD;AACzD,qCAAqC;AACrC,sBAAsB;AACtB,gCAAgC;AAChC,2DAA2D;AAC3D,4BAA4B;AAC5B,8CAA8C;AAC9C,0CAA0C;AAC1C,eAAe;AACf,aAAa;AACb,iFAAiF;AACjF,4BAA4B;AAC5B,iEAAiE;AACjE,mEAAmE;AACnE,6CAA6C;AAC7C,iDAAiD;AACjD,uBAAuB;AACvB,mCAAmC;AACnC,YAAY;AACZ,iBAAiB;AACjB,0EAA0E;AAC1E,UAAU;AACV,iBAAiB;AAEjB,0EAA0E;AAC1E,SAAS;AACT,QAAQ;AACR,kBAAkB;AAClB,KAAK","sourcesContent":["// import { Animates } from \"@mjt-engine/animate\";\n// import { MagicaVoxels } from \"@mjt-engine/magica-voxels\";\n// import { Noises } from \"@mjt-engine/noise\";\n// import { animateExplosion } from \"./animateExplosion\";\n// import { voxDataToComplexModel } from \"./voxDataToComplexModel\";\n\n// export const testVoxels = async () => {\n//   // const ab = await (await fetch(\"voxel/5x5x5.vox\")).arrayBuffer();\n//   // const ab = await (await fetch(\"voxel/teapot.vox\")).arrayBuffer();\n//   // const ab = await (await fetch(\"voxel/castle.vox\")).arrayBuffer();\n//   const ab = await (await fetch(\"voxel/castle.vox\")).arrayBuffer();\n\n//   const parsed = MagicaVoxels.parse(ab);\n//   // console.log({ parsed });\n//   // console.log(JSON.stringify(parsed));\n//   const canvas = document.createElement(\"canvas\");\n//   canvas.width = window.innerWidth;\n//   canvas.height = window.innerHeight;\n//   document.body.appendChild(canvas);\n//   // const visual = Visuals.createVisual(canvas);\n//   const { scene } = visual;\n\n//   // Visuals.setupSceneBasics(scene);\n//   // Visuals.attachEditorControls(scene, {\n//     // parent: visual.engine.getRenderingCanvas(),\n//     parent: document.body,\n//   });\n\n//   // const merged = mergeMeshes(mesh.getChildMeshes(), {\n//   //   multiMultiMaterials: true,\n//   // });\n//   // mesh.getChildMeshes().forEach((m) => m.setEnabled(false));\n//   let mesh = voxDataToComplexModel(scene, parsed, \"test\");\n//   // let mesh = voxDataToMergedModel(scene, parsed, \"test\");\n//   mesh.position = v3([0, 0, -10]);\n//   mesh.rotate(v3([1, 0, 0]), Math.PI);\n//   // const meshes = mesh.getChildMeshes() as Mesh[];\n//   // const explosion = new MeshExploder(meshes);\n//   // explosion.explode(0.5);\n//   // console.log({ meshes });\n//   const ground = getBox(scene, \"ground\", {\n//     width: 200,\n//     height: 200,\n//     depth: 0.01,\n//     position: [0, 0, 4],\n//     color: \"darkgrey\",\n//   });\n//   // ground.material.wireframe = true\n//   let timer = 0;\n//   const random = Noises.noiseStream(Date.now());\n//   let boom = 10;\n//   Animates.create({\n//     ticksPerSecond: 60,\n//     ticker: (tick) => {\n//       scene.render();\n//       if (timer > 100) {\n//         mesh.getChildMeshes().forEach((mesh, index) =>\n//           animateExplosion(mesh, {\n//             random,\n//             radius: 2 + boom,\n//             // maxBounce: 1 + (index % 3 === 0 ? 1 : 0),\n//             maxBounce: 3,\n//             groundZ: ground.position.z - 2,\n//             speed: 10 + 100 * random(),\n//           })\n//         );\n//         if (mesh.getChildMeshes().filter((m) => m.isEnabled()).length === 0) {\n//           mesh.dispose();\n//           mesh = voxDataToComplexModel(scene, parsed, \"test\");\n//           // mesh = voxDataToMergedModel(scene, parsed, \"test\");\n//           mesh.position = v3([0, 0, -10]);\n//           mesh.rotate(v3([1, 0, 0]), Math.PI);\n//           timer = 0;\n//           boom = random() * 100;\n//         }\n//       } else {\n//         // mesh.rotate(v3([0, 0, 1]), (Math.PI * tick.deltaMs) / 1000);\n//       }\n//       timer++;\n\n//       // merged.rotate(v3([1, 1, 1]), (Math.PI * tick.deltaMs) / 1000);\n//     },\n//   });\n//   return scene;\n// };\n"]}